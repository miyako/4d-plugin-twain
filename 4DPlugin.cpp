/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : TWAIN
 #	author : miyako
 #	2017/09/22
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

#pragma mark JPG

namespace JPG
{
	
	struct my_error_mgr {
		struct jpeg_error_mgr pub;
		jmp_buf setjmp_buffer;
		int     jump_set;
	};
	
	typedef struct my_error_mgr *my_error_ptr;
	
	typedef struct {
		struct jpeg_destination_mgr pub; /* public fields */
		
		unsigned char **buf_ptr;
		size_t *bufsize_ptr;
		size_t incsize;
		
		unsigned char *buf;
		size_t bufsize;
		
	} jpeg_memory_destination_mgr;
	
	typedef jpeg_memory_destination_mgr *jpeg_memory_destination_ptr;
	
	void my_error_exit(j_common_ptr cinfo)
	{
		//	my_error_ptr myerr = (my_error_ptr)cinfo->err;
		//
		//	(*cinfo->err->output_message) (cinfo);
		//	if (myerr->jump_set)
		//		longjmp(myerr->setjmp_buffer, 1);
	}
	
	void my_output_message (j_common_ptr cinfo)
	{
		
	}
	
	boolean jpeg_memory_empty_output_buffer (j_compress_ptr cinfo)
	{
		jpeg_memory_destination_ptr dest = (jpeg_memory_destination_ptr) cinfo->dest;
		unsigned char *newbuf;
		/* abort if incsize is 0 (no expansion of buffer allowed) */
		if (dest->incsize == 0) return _false;
		/* otherwise, try expanding buffer... */
		newbuf = (unsigned char *)realloc(dest->buf,dest->bufsize + dest->incsize);
		if (!newbuf) return _false;
		dest->pub.next_output_byte = newbuf + dest->bufsize;
		dest->pub.free_in_buffer = dest->incsize;
		dest->buf = newbuf;
		dest->bufsize += dest->incsize;
		dest->incsize *= 2;
		return _true;
	}
	
	void jpeg_memory_init_destination (j_compress_ptr cinfo)
	{
		jpeg_memory_destination_ptr dest = (jpeg_memory_destination_ptr) cinfo->dest;
		dest->pub.next_output_byte = dest->buf;
		dest->pub.free_in_buffer = dest->bufsize;
	}
	
	void jpeg_memory_term_destination (j_compress_ptr cinfo)
	{
		jpeg_memory_destination_ptr dest = (jpeg_memory_destination_ptr) cinfo->dest;
		*dest->buf_ptr = dest->buf;
		*dest->bufsize_ptr = dest->bufsize - dest->pub.free_in_buffer;
	}
	
	void jpeg_memory_dest (j_compress_ptr cinfo, unsigned char **bufptr, size_t *bufsizeptr, size_t incsize)
	{
		jpeg_memory_destination_ptr dest;
		
		/* allocate destination manager object for compress object, if needed */
		if (!cinfo->dest) {
			cinfo->dest = (struct jpeg_destination_mgr *)
			(*cinfo->mem->alloc_small) ( (j_common_ptr) cinfo,
																	JPOOL_PERMANENT,
																	sizeof(jpeg_memory_destination_mgr) );
		}
		
		dest = (jpeg_memory_destination_ptr)cinfo->dest;
		
		dest->buf_ptr = bufptr;
		dest->buf = *bufptr;
		dest->bufsize_ptr = bufsizeptr;
		dest->bufsize = *bufsizeptr;
		dest->incsize = incsize;
		
		dest->pub.init_destination = jpeg_memory_init_destination;
		dest->pub.empty_output_buffer = jpeg_memory_empty_output_buffer;
		dest->pub.term_destination = jpeg_memory_term_destination;
	}
	
	PA_Picture write_data(C_BLOB &data,
												int width,
												int height,
												int depth,
												int bytes_per_line,
												J_COLOR_SPACE color,
												int dpi_x = DEFAULT_RESOLUTION,
												int dpi_y = DEFAULT_RESOLUTION,
												int quality = 100)
	{
		PA_Picture picture;
		
		//		JSAMPARRAY buf = 0;
		struct jpeg_compress_struct cinfo;
		struct my_error_mgr jcerr;
		
		/* initialize compression object */
		cinfo.err = jpeg_std_error(&jcerr.pub);
		jpeg_create_compress(&cinfo);
		jcerr.pub.error_exit = my_error_exit;
		jcerr.pub.output_message = my_output_message;
		jcerr.jump_set = 0;
		
		if (setjmp(jcerr.setjmp_buffer))
		{
			/* error handler for compress failures */
			jpeg_abort_compress(&cinfo);
			jcerr.jump_set=0;
		} else {
			jcerr.jump_set=1;
		}
		
		size_t outbuffersize = data.getBytesLength() + 32768;
		unsigned char *outbuffer = (unsigned char *)malloc(outbuffersize);
		
		if(outbuffer)
		{
			jpeg_memory_dest(&cinfo, &outbuffer, &outbuffersize, 65536);
			
			cinfo.in_color_space = color;
			cinfo.input_components = (color == JCS_RGB) ? 3 : 1;
			cinfo.image_width = width;
			cinfo.image_height = height;
			jpeg_set_defaults(&cinfo);
			//jpeg_set_defaults overrides density
			cinfo.density_unit = 1;   /* Inches */
			cinfo.X_density = dpi_x;
			cinfo.Y_density = dpi_y;
			cinfo.write_JFIF_header = _true;
			jpeg_set_quality(&cinfo, quality, _true);
			jpeg_simple_progression(&cinfo);
			cinfo.optimize_coding = _true;
			jpeg_start_compress(&cinfo, _true);
			
			unsigned char *p = (unsigned char *)data.getBytesPtr();
			
			JSAMPLE *jpegbuf = (JSAMPLE *)malloc(bytes_per_line);
			
			if(jpegbuf)
			{
				for(int y = 0; y < height; y++)
				{
					if((y % 0x2000)==0) PA_YieldAbsolute();
					
					if(depth == 1)
					{
						JSAMPLE *buf8 = (JSAMPLE *)malloc(bytes_per_line * 8);
						for(int col1 = 0; col1 < bytes_per_line; col1++)
						{
							for(int col8 = 0; col8 < 8; col8++)
							{
								buf8[col1 * 8 + col8] = p[col1] & (1 << (8 - col8 - 1)) ? 0 : 0xff;
							}
						}
						jpeg_write_scanlines(&cinfo, &buf8, 1);
						free(buf8);
					}else
					{
						memcpy(jpegbuf, p, bytes_per_line);
						jpeg_write_scanlines(&cinfo, &jpegbuf, 1);
					}
					p += bytes_per_line;
				}//height
				free(jpegbuf);
			}
			
			jpeg_finish_compress(&cinfo);
			jpeg_destroy_compress(&cinfo);
			
			picture = PA_CreatePicture((void *)outbuffer, (PA_long32)outbuffersize);
			free(outbuffer);
		}//outbuffer
		else
		{
			unsigned char nodata = 0;
			picture = PA_CreatePicture((void *)&nodata, 0);
		}
		
		return picture;
	}
}

#pragma mark PNG

namespace PNG
{
	void write_data_fn(png_structp png_ptr, png_bytep buf, png_size_t size)
	{
		C_BLOB *blob = (C_BLOB *)png_get_io_ptr(png_ptr);
		blob->addBytes((const uint8_t *)buf, (uint32_t)size);
	}
	
	void output_flush_fn(png_structp png_ptr)
	{
		
	}
	
	PA_Picture write_data(C_BLOB &data,
												int width,
												int height,
												int depth,
												int bytes_per_line,
												int color,
												int dpi_x = DEFAULT_RESOLUTION,
												int dpi_y = DEFAULT_RESOLUTION)
	{
		C_BLOB png;
		
		png_structp png_ptr;
		png_infop info_ptr;
		
		png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
		if(png_ptr)
		{
			info_ptr = png_create_info_struct(png_ptr);
			if(info_ptr)
			{
				if(setjmp(png_jmpbuf(png_ptr)))
				{
					png_destroy_write_struct(&png_ptr, &info_ptr);
				}else{
					
					png_set_write_fn(png_ptr, (png_voidp)&png, write_data_fn, output_flush_fn);
					
					png_set_IHDR(png_ptr, info_ptr,
											 width, //pixels_per_line
											 height,//lines
											 depth,
											 color,
											 PNG_INTERLACE_NONE,
											 PNG_COMPRESSION_TYPE_DEFAULT,
											 PNG_FILTER_TYPE_DEFAULT);
					
					png_set_pHYs(png_ptr, info_ptr,
											 dpi_x * INCHES_PER_METER,
											 dpi_y * INCHES_PER_METER,
											 PNG_RESOLUTION_METER);
					
					//TODO:support icc_profile
					
					png_write_info(png_ptr, info_ptr);
					
					unsigned char *p = (unsigned char *)data.getBytesPtr();
					
					/*
					 //takes as much time, with no way to yield
					 std::vector<png_byte *>rows(height);
					 for(int y = 0; y < height; y++)
					 {
					 rows[y] = p;
					 p += bytes_per_line;
					 }//height
					 png_write_image(png_ptr, &rows[0]);
					 */
					
					for(int y = 0; y < height; y++)
					{
						if((y % 0x2000)==0) PA_YieldAbsolute();
						
						//byteswap for depth 16
						if (depth == 16)
						{
							unsigned char *byte_l, *byte_h, *ptr;
							ptr = p;
							for (int j = 0; j < bytes_per_line; j += 2)
							{
								byte_l = ptr;
								byte_h = ptr + 1;
								unsigned char b = *byte_l;
								*byte_l = *byte_h;
								*byte_h = b;
								ptr += 2;
							}
						}
						
						png_write_row(png_ptr, p);
						p += bytes_per_line;
					}//height
					
					png_write_end(png_ptr, info_ptr);
					png_destroy_write_struct(&png_ptr, &info_ptr);
				}
			}
		}
		return PA_CreatePicture((void *)png.getBytesPtr(), png.getBytesLength());
	}
}

namespace DSM
{
	TW_IDENTITY tw_identity;
	TW_IDENTITY tw_source;
	
	TW_UINT16 tw_state = DSM_STATE_NO_SESSION;
	
	HWND tw_parent = NULL;
	TW_USERINTERFACE tw_userinterface;

#if USE_TWAIN_DSM
	TW_ENTRYPOINT dsm_ptr;
#endif
	TW_HANDLE Alloc(TW_UINT32 size)
	{
#if USE_TWAIN_DSM
		if(DSM::dsm_ptr.DSM_MemAllocate)
		{
			return DSM::dsm_ptr.DSM_MemAllocate(size);
		}
#endif
#if VERSIONWIN
		return ::GlobalAlloc(GPTR, size);
#endif
		return 0;
	}
	void Free(TW_HANDLE h)
	{
#if USE_TWAIN_DSM
		if(DSM::dsm_ptr.DSM_MemFree)
		{
			return DSM::dsm_ptr.DSM_MemFree(h);
		}
#endif
#if VERSIONWIN
		::GlobalFree(h);
#endif
		return;
	}
	TW_MEMREF Lock(TW_HANDLE h)
	{
#if USE_TWAIN_DSM
		if(DSM::dsm_ptr.DSM_MemLock)
		{
			return DSM::dsm_ptr.DSM_MemLock(h);
		}
#endif
#if VERSIONWIN
		return ::GlobalLock(h);
#endif
		return 0;
	}
	void Unlock(TW_HANDLE h)
	{
#if USE_TWAIN_DSM
		if(DSM::dsm_ptr.DSM_MemUnlock)
		{
			return DSM::dsm_ptr.DSM_MemUnlock(h);
		}
#endif
#if VERSIONWIN
		::GlobalUnlock(h);
#endif
		return;
	}
}

namespace TWAIN
{
#pragma mark -
	
	void copyIdentity(TW_IDENTITY *tw_identity)
	{
		//init
		memset(tw_identity, 0, sizeof(TW_IDENTITY));
		memset(&DSM::tw_userinterface, 0, sizeof(TW_USERINTERFACE));
		DSM::tw_userinterface.ShowUI = false;
		DSM::tw_userinterface.ModalUI = false;
		//language
		PA_Variable args[1];
		args[0] = PA_CreateVariable(eVK_Longint);
		PA_SetLongintVariable(&args[0], 0);
		PA_Unistring ret = PA_GetStringVariable(PA_ExecuteCommandByID(CMD_Get_database_localization , args, 1));
		if(!PA_CompareUniBuffers(ret.fString, ret.fLength, (PA_Unichar *)"j\0a\0@\0\0\0", 3, 0, 1))
		{
			tw_identity->Version.Language = TWLG_JAPANESE;
			tw_identity->Version.Country = TWCY_JAPAN;
		}else
		if(!PA_CompareUniBuffers(ret.fString, ret.fLength, (PA_Unichar *)"f\0r\0@\0\0\0", 3, 0, 1))
		{
			tw_identity->Version.Language = TWLG_FRENCH;
			tw_identity->Version.Country = TWCY_FRANCE;
		}else
		if(!PA_CompareUniBuffers(ret.fString, ret.fLength, (PA_Unichar *)"d\0e\0@\0\0\0", 3, 0, 1))
		{
			tw_identity->Version.Language = TWLG_GERMAN;
			tw_identity->Version.Country = TWCY_GERMANY;
		}else
		if(!PA_CompareUniBuffers(ret.fString, ret.fLength, (PA_Unichar *)"e\0s\0@\0\0\0", 3, 0, 1))
		{
			tw_identity->Version.Language = TWLG_SPANISH;
			tw_identity->Version.Country = TWCY_SPAIN;
		}else
		{
			tw_identity->Version.Language = TWLG_ENGLISH;
			tw_identity->Version.Country = TWCY_USA;
		}
		PA_ClearVariable(&args[0]);
		
		printf("language:%d:%d\n", tw_identity->Version.Language, tw_identity->Version.Country);
		
		//version
		PA_ulong32 version = PA_Get4DVersion();
		TW_UINT16 majorNum = (version & 0x0000FF00) >> 8;
		TW_UINT16 minorNum = (version & 0x000000FF);
		char _majorNum[3];
		sprintf(_majorNum, "%X", majorNum);
		char _minorNum[3];
		sprintf(_minorNum, "%X", minorNum);
		tw_identity->Id = 0;//always 0
		tw_identity->Version.MajorNum = atoi(_majorNum);
		tw_identity->Version.MinorNum = atoi(_minorNum);
		char _versionInfo[6];
		sprintf(_versionInfo, "%X.%X", majorNum, minorNum);
		SSTRCPY(tw_identity->Version.Info, sizeof(tw_identity->Version.Info), _versionInfo);
		
		//protocol
		tw_identity->ProtocolMajor = TWON_PROTOCOLMAJOR;
		tw_identity->ProtocolMinor = TWON_PROTOCOLMINOR;
		/*
			note: TWAIN.framework on Mac is 1.9
			TWAIN_32.DLL on Windows is 1.x and 32-bit only
			TWAINDSM.DLL on Windows is 2.3 and 32-bit or 64-bit
			TWAINDSM.DYLIB does not work on Mac (dlopen can't open .ds)
		 */
#if USE_TWAIN_DSM
		tw_identity->SupportedGroups = DF_APP2 | DG_IMAGE | DG_CONTROL;
#else
		tw_identity->SupportedGroups = DG_IMAGE | DG_CONTROL;
#endif
		
		SSTRCPY(tw_identity->Manufacturer, sizeof(tw_identity->Manufacturer), PRODUCT_VENDOR_NAME);
		SSTRCPY(tw_identity->ProductFamily, sizeof(tw_identity->ProductFamily), PRODUCT_FAMILY_NAME);
		SSTRCPY(tw_identity->ProductName, sizeof(tw_identity->ProductName), PRODUCT_NAME);
	}
	
	TW_INT16 getCondition()
	{
		TW_INT16 condition = 0;
		
		TW_STATUS status;
		memset(&status, 0, sizeof(TW_STATUS));
		
		if(TWRC_SUCCESS == DSM_Entry(
																 &DSM::tw_identity,
																 0,
																 DG_CONTROL,
																 DAT_STATUS,
																 MSG_GET,
																 (TW_MEMREF)&status))
		{
			condition = status.ConditionCode;
		}
		return condition;
	}
	
#pragma mark DSM
	
	TW_UINT16 openManager()
	{
		TW_UINT16 ret = DSM_Entry(
															&DSM::tw_identity,
															0,
															DG_CONTROL,
															DAT_PARENT,
															MSG_OPENDSM,
															(TW_MEMREF)&DSM::tw_parent);
	if(ret == TWRC_SUCCESS)
	{
		DSM::tw_state = DSM_STATE_NO_SOURCE;
#if VERSIONWIN
		DSM::tw_userinterface.hParent = DSM::tw_parent;
#endif
#if USE_TWAIN_DSM
		if((DSM::tw_identity.SupportedGroups & DF_DSM2) == DF_DSM2)
		{
			DSM::dsm_ptr.Size = sizeof(TW_ENTRYPOINT);
			ret = DSM_Entry(
											&DSM::tw_identity,
											0,
											DG_CONTROL,
											DAT_ENTRYPOINT,
											MSG_GET,
											(TW_MEMREF)&DSM::dsm_ptr);
		}//DF_DSM2
#endif
	}
		
		return ret;
	}
	
	TW_UINT16 closeManager()
	{
		TW_UINT16 ret = DSM_Entry(
															&DSM::tw_identity,
															0,
															DG_CONTROL,
															DAT_PARENT,
															MSG_CLOSEDSM,
															(TW_MEMREF)&DSM::tw_parent);
		if(ret == TWRC_SUCCESS)
		{
			DSM::tw_state = DSM_STATE_NO_SESSION;
		}
		
		return ret;
	}
	

	/*
	 
#pragma mark DS (UI)
	
	void userSelect(tw_source_t *source)
	{
		TW_IDENTITY tw_source;
		memset(&tw_source, 0, sizeof(TW_IDENTITY));
		
		if(TWRC_SUCCESS == DSM_Entry(
																 &DSM::tw_identity,
																 0,
																 DG_CONTROL,
																 DAT_IDENTITY,
																 MSG_USERSELECT,
																 (TW_MEMREF)&tw_source))
		{
			source->isValid = TRUE;
			memcpy(&source->identity, &tw_source, sizeof(TW_IDENTITY));
		}
	}
	
	void selectSource()
	{
		tw_source_t source;
		source.isValid = FALSE;
		memset(&source.identity, 0, sizeof(TW_IDENTITY));
		
		PA_RunInMainProcess((PA_RunInMainProcessProcPtr)userSelect, &source);
		
		if(source.isValid)
		{
			DSM_Entry(
								&DSM::tw_identity,
								0,
								DG_CONTROL,
								DAT_IDENTITY,
								MSG_SET,
								(TW_MEMREF)&source.identity);
		}
	}
	 */
	
#pragma mark DS
	
	BOOL getDefaultSource(TW_IDENTITY *source)
	{
		BOOL success = FALSE;
		
		TW_IDENTITY tw_source;
		memset(&tw_source, 0, sizeof(TW_IDENTITY));
		
		success = (TWRC_SUCCESS == DSM_Entry(
																				 &DSM::tw_identity,
																				 0,
																				 DG_CONTROL,
																				 DAT_IDENTITY,
																				 MSG_GETDEFAULT,
																				 (TW_MEMREF)&tw_source));

		memcpy(source, &tw_source, sizeof(TW_IDENTITY));
		
		return success;
	}
	
	void getSources(std::vector<TW_IDENTITY>& sources)
	{
		TW_INT16 condition = 0;
		
		TW_IDENTITY tw_source;
		memset(&tw_source, 0, sizeof(TW_IDENTITY));
		TW_UINT16 ret = DSM_Entry(
															&DSM::tw_identity,
															0,
															DG_CONTROL,
															DAT_IDENTITY,
															MSG_GETFIRST,
															(TW_MEMREF)&tw_source);
		switch (ret)
		{
			case TWRC_SUCCESS:
				sources.push_back(tw_source);
				do
				{
					memset(&tw_source, 0, sizeof(TW_IDENTITY));
					ret = DSM_Entry(
													&DSM::tw_identity,
													0,
													DG_CONTROL,
													DAT_IDENTITY,
													MSG_GETNEXT,
													(TW_MEMREF)&tw_source);
					switch (ret)
					{
						case TWRC_SUCCESS:
							sources.push_back(tw_source);
							break;
						case TWRC_ENDOFLIST:
							//TWRC_ENDOFLIST
							break;
						case TWRC_FAILURE:
							condition = getCondition();
							break;
						default:
							
							break;
					}
				}
				while (TWRC_SUCCESS == ret);
				break;
			case TWRC_ENDOFLIST:
				//TWRC_ENDOFLIST
				break;
			case TWRC_FAILURE:
				condition = getCondition();
				break;
			default:
				
				break;
		}
	}

	void getSources(ARRAY_TEXT& Param1)
	{
		Param1.setSize(1);
		
		JSONNODE *json_scanners = json_new(JSON_ARRAY);
		
		TW_UINT16 original_tw_state = DSM::tw_state;
		
		if(DSM::tw_state < DSM_STATE_NO_SOURCE)//<2
		{
			openManager();//=2
		}
		
		if(DSM::tw_state > DSM_STATE_NO_SESSION)
		{
			std::vector<TW_IDENTITY>sources;
			
			getSources(sources);
			
			for(std::vector<TW_IDENTITY>::iterator it = sources.begin(); it < sources.end(); it++)
			{
				TW_IDENTITY tw_source = *it;
				JSONNODE *json_scanner = json_new(JSON_NODE);
				json_set_text(json_scanner, L"Manufacturer", (char *)tw_source.Manufacturer);
				json_set_text(json_scanner, L"ProductFamily", (char *)tw_source.ProductFamily);
				json_set_text(json_scanner, L"ProductName", (char *)tw_source.ProductName);
				
				//Version
				JSONNODE *json_scanner_version = json_new(JSON_NODE);
				json_set_text(json_scanner_version, L"Info", (char *)tw_source.Version.Info);
				json_set_i(json_scanner_version, L"MinorNum", tw_source.Version.MajorNum);
				json_set_i(json_scanner_version, L"MinorNum", tw_source.Version.MinorNum);
				json_set_i(json_scanner_version, L"Language", tw_source.Version.Language);
				json_set_i(json_scanner_version, L"Country", tw_source.Version.Country);
				json_set_name(json_scanner_version, L"Version");
				json_push_back(json_scanner, json_scanner_version);
				
				json_set_i(json_scanner, L"ProtocolMajor", tw_source.ProtocolMajor);
				json_set_i(json_scanner, L"ProtocolMinor", tw_source.ProtocolMinor);
				json_set_i(json_scanner, L"SupportedGroups", tw_source.SupportedGroups);
				
				json_push_back(json_scanners, json_scanner);
				CUTF8String scanner = (const uint8_t *)tw_source.ProductName;
				Param1.appendUTF8String(&scanner);
			}
			
			
			if(original_tw_state < DSM_STATE_NO_SOURCE)
			{
				closeManager();
			}
		}
		
		//dump json in element #0
		CUTF16String json;
		json_stringify(json_scanners, json);
		json_delete(json_scanners);
		Param1.setUTF16StringAtIndex(&json, 0);
	}
	
	BOOL getSource(C_TEXT &name, TW_IDENTITY *source)
	{
		BOOL success = FALSE;
		
		CUTF8String _name;
		name.copyUTF8String(&_name);
		
		std::vector<TW_IDENTITY>sources;
		
		getSources(sources);
		
		for(std::vector<TW_IDENTITY>::iterator it = sources.begin(); it < sources.end(); it++)
		{
			TW_IDENTITY tw_source = *it;
			
			size_t len = strlen((char *)tw_source.ProductName);
			if(len == _name.length())
			{
				if(0 == strncmp((char *)tw_source.ProductName, (char *)_name.c_str(), len))
				{
					memcpy(source, &tw_source, sizeof(TW_IDENTITY));
					DSM::tw_state = DSM_STATE_NOT_OPEN;
					success = TRUE;
					break;
				}
			}
		}
		
		return success ? success : getDefaultSource(source);
	}
	
	TW_UINT16 openSource(TW_IDENTITY *source)
	{
		TW_UINT16 ret = DSM_Entry(
															&DSM::tw_identity,
															0,
															DG_CONTROL,
															DAT_IDENTITY,
															MSG_OPENDS,
															(TW_MEMREF)source);
		if(TWRC_SUCCESS == ret)
		{
			DSM::tw_state = DSM_STATE_NOT_ENABLED;
		}
		
		return ret;
	}

	TW_UINT16 enableSource(TW_IDENTITY *source)
	{
		TW_UINT16 ret = DSM_Entry(
															&DSM::tw_identity,
															source,
															DG_CONTROL,
															DAT_USERINTERFACE,
															MSG_ENABLEDS,
															(TW_MEMREF)&DSM::tw_userinterface);
		if(TWRC_SUCCESS == ret)
		{
			DSM::tw_state = DSM_STATE_NOT_READY;
		}
		
		return ret;
	}

	TW_UINT16 disableSource(TW_IDENTITY *source)
	{
		TW_UINT16 ret = DSM_Entry(
															&DSM::tw_identity,
															source,
															DG_CONTROL,
															DAT_USERINTERFACE,
															MSG_DISABLEDS,
															(TW_MEMREF)&DSM::tw_userinterface);
		if(TWRC_SUCCESS == ret)
		{
			DSM::tw_state = DSM_STATE_NOT_ENABLED;
		}
		
		return ret;
	}

	TW_UINT16 processEvent(TW_IDENTITY *source, TW_EVENT *dsevent)
	{
		TW_UINT16 ret = TWRC_NOTDSEVENT;

		//timeout to avoid freeze
		time_t now = time(NULL);
		time_t end = now + TWAIN_PROCESS_EVENT_TIMEOUT;
		
		while((ret == TWRC_NOTDSEVENT) && (time(NULL) < end))
		{
			PA_YieldAbsolute();
			
			ret = DSM_Entry(
										 &DSM::tw_identity,
										 source,
										 DG_CONTROL,
										 DAT_EVENT,
										 MSG_PROCESSEVENT,
										 (TW_MEMREF)dsevent);
		}
		return ret;
	}
		
	TW_UINT16 closeSource(TW_IDENTITY *source)
	{
		TW_UINT16 ret = DSM_Entry(
															&DSM::tw_identity,
															0,
															DG_CONTROL,
															DAT_IDENTITY,
															MSG_CLOSEDS,
															(TW_MEMREF)source);
		if(TWRC_SUCCESS == ret)
		{
			DSM::tw_state = DSM_STATE_NO_SOURCE;
		}
		
		return ret;
	}
	
#pragma mark -
	
	void getOption(TW_UINT16 cap, C_TEXT& Param1, C_TEXT& returnValue)
	{
		if(DSM::tw_state > DSM_STATE_NO_SOURCE)
		{
			TW_CAPABILITY tw_capability;
			memset(&tw_capability, 0, sizeof(TW_CAPABILITY));
			
			tw_capability.Cap = cap;
			tw_capability.ConType = TWON_ONEVALUE;
			tw_capability.hContainer = 0;
			
			if(TWRC_SUCCESS == DSM_Entry(
																	 &DSM::tw_identity,
																	 &DSM::tw_source,
																	 DG_CONTROL,
																	 DAT_CAPABILITY,
																	 MSG_GET,
																	 (TW_MEMREF)&tw_capability))
			{
				pTW_ONEVALUE p = (pTW_ONEVALUE)DSM::Lock(tw_capability.hContainer);
				getCapabilityValueString(&tw_capability, p, returnValue);
				DSM::Unlock(tw_capability.hContainer);
				DSM::Free(tw_capability.hContainer);
			}
	
		}
		
	}

	void setOption(TW_UINT16 cap, C_TEXT& Param1, C_TEXT& Param3)
	{
		if(DSM::tw_state > DSM_STATE_NO_SOURCE)
		{
			TW_CAPABILITY tw_capability;
			memset(&tw_capability, 0, sizeof(TW_CAPABILITY));
			
			tw_capability.Cap = cap;
			tw_capability.ConType = 0;
			tw_capability.hContainer = 0;

			if(TWRC_SUCCESS == DSM_Entry(
																	 &DSM::tw_identity,
																	 &DSM::tw_source,
																	 DG_CONTROL,
																	 DAT_CAPABILITY,
																	 MSG_GET,
																	 (TW_MEMREF)&tw_capability))
			{
				TW_UINT16 itemType = 0;
				TW_UINT32 numItems = 0;
				TW_UINT32 contSize = 0;
				
				//get itemType from old handle
				void *_p = DSM::Lock(tw_capability.hContainer);
				switch(tw_capability.ConType)
				{
					case TWON_ARRAY:
		
						break;
					case TWON_ENUMERATION:
						itemType = ((pTW_ENUMERATION)_p)->ItemType;
						numItems = ((pTW_ENUMERATION)_p)->NumItems;
						contSize = sizeof(TW_ENUMERATION) + (getSizeForItemType(itemType) * numItems);
						break;
					case TWON_ONEVALUE:
						itemType = ((pTW_ONEVALUE)_p)->ItemType;
						contSize = sizeof(TW_ONEVALUE);
						break;
					case TWON_RANGE:
						itemType = ((pTW_RANGE)_p)->ItemType;
						contSize = sizeof(TW_RANGE);
						break;
				}
				//_p
				DSM::Unlock(tw_capability.hContainer);
				DSM::Free(tw_capability.hContainer);
				
				if(contSize)
				{
					tw_capability.hContainer = DSM::Alloc(contSize);
					
					void *p = DSM::Lock(tw_capability.hContainer);
					
					switch(tw_capability.ConType)
					{
						case TWON_ARRAY:
							
							break;
						case TWON_ENUMERATION:
							((pTW_ENUMERATION)p)->ItemType = itemType;
							((pTW_ENUMERATION)p)->NumItems = numItems;
							break;
						case TWON_ONEVALUE:
							((pTW_ONEVALUE)p)->ItemType = itemType;
							break;
						case TWON_RANGE:
							((pTW_RANGE)p)->ItemType = itemType;
							break;
					}
					
					setCapabilityValueString(&tw_capability, p, Param3);
					
					if(TWRC_SUCCESS == DSM_Entry(
																			 &DSM::tw_identity,
																			 &DSM::tw_source,
																			 DG_CONTROL,
																			 DAT_CAPABILITY,
																			 MSG_SET,
																			 (TW_MEMREF)&tw_capability))
					{
						
					}
					DSM::Unlock(tw_capability.hContainer);
					DSM::Free(tw_capability.hContainer);
				}

			}
		
		}
		
	}
	
	void getOptionValue(JSONNODE *json_scanner_options, TW_IDENTITY *source, ARRAY_TEXT &Param2, ARRAY_TEXT &Param3, TW_UINT16 cap)
	{
		TW_CAPABILITY tw_capability;
		memset(&tw_capability, 0, sizeof(TW_CAPABILITY));
		
		tw_capability.Cap = cap;
		tw_capability.ConType = 0;
		tw_capability.hContainer = 0;
		
		if(TWRC_SUCCESS == DSM_Entry(
																 &DSM::tw_identity,
																 source,
																 DG_CONTROL,
																 DAT_CAPABILITY,
																 MSG_QUERYSUPPORT,
																 (TW_MEMREF)&tw_capability))
		{
			std::wstring optionName;
			getStringFromCapability(cap, optionName);
			
			JSONNODE *json_scanner_option = json_new(JSON_NODE);
			//flags (MSG_QUERYSUPPORT)
			pTW_ONEVALUE p = (pTW_ONEVALUE)DSM::Lock(tw_capability.hContainer);
			JSONNODE *json_scanner_option_flags = json_new(JSON_NODE);
			json_set_bool(json_scanner_option_flags, L"selectable", (TWQC_SET & p->Item) != 0);
			json_set_bool(json_scanner_option_flags, L"detectable", (TWQC_GET & p->Item) != 0);
			json_set_name(json_scanner_option_flags, L"flags");
			json_push_back(json_scanner_option, json_scanner_option_flags);
			DSM::Unlock(tw_capability.hContainer);
			DSM::Free(tw_capability.hContainer);
			//name
			json_push_back(json_scanner_option, json_new_a(L"name", optionName.c_str()));

#if VERSIONMAC
			uint32_t dataSize = (uint32_t)((optionName.length() * sizeof(wchar_t))+ sizeof(PA_Unichar));
			std::vector<char> buf(dataSize);
			uint32_t len = PA_ConvertCharsetToCharset((char *)optionName.c_str(),
																								(PA_long32)(optionName.length() * sizeof(wchar_t)),
																								eVTC_UTF_32,
																								(char *)&buf[0],
																								dataSize,
																								eVTC_UTF_16);
			Param2.appendUTF16String((const PA_Unichar *)&buf[0], len);
#else
			Param2.appendUTF16String((const PA_Unichar *)optionName.c_str(), optionName.length());
#endif
			
			C_TEXT returnValue;
			
			tw_capability.ConType = 0;
			tw_capability.hContainer = 0;
			if(TWRC_SUCCESS == DSM_Entry(
																	 &DSM::tw_identity,
																	 source,
																	 DG_CONTROL,
																	 DAT_CAPABILITY,
																	 MSG_GET,
																	 (TW_MEMREF)&tw_capability))
			{
				//options
				char str[CAP_VALUE_BUF_SIZE];
				JSONNODE *json_scanner_option_values = json_new(JSON_ARRAY);
				json_set_name(json_scanner_option_values, L"values");
				
				switch(tw_capability.ConType)
				{
					case TWON_ARRAY:
					{
						pTW_ARRAY p = (pTW_ARRAY)DSM::Lock(tw_capability.hContainer);
						json_set_i(json_scanner_option, L"type", p->ItemType);
						for (int i = 0; i < p->NumItems;++i)
						{
							switch(p->ItemType)
							{
								case TWTY_FIX32:
								{
									pTW_FIX32 pFix32 = &((pTW_FIX32)(&p->ItemList))[i];
									JSONNODE *json_number = json_new(JSON_NUMBER);
									json_set_f(json_number, float(pFix32->Whole) + float(pFix32->Frac / 65536.0));
									json_push_back(json_scanner_option_values, json_number);
								}
									break;
								case TWTY_FRAME:
								{
									pTW_FRAME pframe = &((pTW_FRAME)(&p->ItemList))[i];
									sprintf(str, "%d.%u,%d.%u,%d.%u,%d.%u",
													pframe->Top.Whole, pframe->Top.Frac,
													pframe->Left.Whole, pframe->Left.Frac,
													pframe->Right.Whole, pframe->Right.Frac,
													pframe->Bottom.Whole, pframe->Bottom.Frac);
								}
									break;
								case TWTY_INT8:
								case TWTY_INT16:
								case TWTY_INT32:
								case TWTY_UINT8:
								case TWTY_UINT16:
								case TWTY_UINT32:
								{
									TW_UINT32 currentValue = ((pTW_UINT32)(&p->ItemList))[i];
									JSONNODE *json_number = json_new(JSON_NUMBER);
									json_set_i(json_number, currentValue);
									json_push_back(json_scanner_option_values, json_number);
								}
									break;
								case TWTY_BOOL:
								{
									TW_UINT32 currentValue = ((pTW_UINT32)(&p->ItemList))[i];
									JSONNODE *json_bool = json_new(JSON_BOOL);
									json_set_b(json_bool, currentValue);
									json_push_back(json_scanner_option_values, json_bool);
								}
									break;
								case TWTY_STR32:
								{
									pTW_STR32 pStr32 = &((pTW_STR32)(&p->ItemList))[i];
									sprintf(str, "%s", pStr32);
									JSONNODE *json_text = json_new(JSON_STRING);
									json_set_text(json_text, str);
									json_push_back(json_scanner_option_values, json_text);
								}
									break;
								case TWTY_STR64:
								{
									pTW_STR64 pStr64 = &((pTW_STR64)(&p->ItemList))[i];
									sprintf(str, "%s", pStr64);
									JSONNODE *json_text = json_new(JSON_STRING);
									json_set_text(json_text, str);
									json_push_back(json_scanner_option_values, json_text);
								}
									break;
								case TWTY_STR128:
								{
									pTW_STR128 pStr128 = &((pTW_STR128)(&p->ItemList))[i];
									sprintf(str, "%s", pStr128);
									JSONNODE *json_text = json_new(JSON_STRING);
									json_set_text(json_text, str);
									json_push_back(json_scanner_option_values, json_text);
								}
									break;
								case TWTY_STR255:
								{
									pTW_STR255 pStr255 = &((pTW_STR255)(&p->ItemList))[i];
									sprintf(str, "%s", pStr255);
									JSONNODE *json_text = json_new(JSON_STRING);
									json_set_text(json_text, str);
									json_push_back(json_scanner_option_values, json_text);
								}
									break;
									//					case TWTY_STR1024:
									//					case TWTY_UNI512:
									//						break;
								default:
									break;
							}
						}
						DSM::Unlock(tw_capability.hContainer);
						DSM::Free(tw_capability.hContainer);
					}
						break;
					case TWON_ENUMERATION:
					{
						pTW_ENUMERATION p = (pTW_ENUMERATION)DSM::Lock(tw_capability.hContainer);
						json_set_i(json_scanner_option, L"type", p->ItemType);
						for (int i = 0; i < p->NumItems;++i)
						{
							switch(p->ItemType)
							{
								case TWTY_FIX32:
								{
									pTW_FIX32 pFix32 = &((pTW_FIX32)(&p->ItemList))[i];
									JSONNODE *json_number = json_new(JSON_NUMBER);
									json_set_f(json_number, float(pFix32->Whole) + float(pFix32->Frac / 65536.0));
									json_push_back(json_scanner_option_values, json_number);				
								}
									break;
								case TWTY_FRAME:
								{
									pTW_FRAME pframe = &((pTW_FRAME)(&p->ItemList))[i];
									sprintf(str, "%d.%u,%d.%u,%d.%u,%d.%u",
													pframe->Top.Whole, pframe->Top.Frac,
													pframe->Left.Whole, pframe->Left.Frac,
													pframe->Right.Whole, pframe->Right.Frac,
													pframe->Bottom.Whole, pframe->Bottom.Frac);
								}
									break;
								case TWTY_INT8:
								case TWTY_INT16:
								case TWTY_INT32:
								case TWTY_UINT8:
								case TWTY_UINT16:
								case TWTY_UINT32:
								{
									TW_UINT32 currentValue = ((pTW_UINT32)(&p->ItemList))[i];
									JSONNODE *json_number = json_new(JSON_NUMBER);
									json_set_i(json_number, currentValue);
									json_push_back(json_scanner_option_values, json_number);
								}
									break;
								case TWTY_BOOL:
								{
									TW_UINT32 currentValue = ((pTW_UINT32)(&p->ItemList))[i];
									JSONNODE *json_bool = json_new(JSON_BOOL);
									json_set_b(json_bool, currentValue);
									json_push_back(json_scanner_option_values, json_bool);
								}
									break;
								case TWTY_STR32:
								{
									pTW_STR32 pStr32 = &((pTW_STR32)(&p->ItemList))[i];
									sprintf(str, "%s", pStr32);
									JSONNODE *json_text = json_new(JSON_STRING);
									json_set_text(json_text, str);
									json_push_back(json_scanner_option_values, json_text);
								}
									break;
								case TWTY_STR64:
								{
									pTW_STR64 pStr64 = &((pTW_STR64)(&p->ItemList))[i];
									sprintf(str, "%s", pStr64);
									JSONNODE *json_text = json_new(JSON_STRING);
									json_set_text(json_text, str);
									json_push_back(json_scanner_option_values, json_text);
								}
									break;
								case TWTY_STR128:
								{
									pTW_STR128 pStr128 = &((pTW_STR128)(&p->ItemList))[i];
									sprintf(str, "%s", pStr128);
									JSONNODE *json_text = json_new(JSON_STRING);
									json_set_text(json_text, str);
									json_push_back(json_scanner_option_values, json_text);
								}
									break;
								case TWTY_STR255:
								{
									pTW_STR255 pStr255 = &((pTW_STR255)(&p->ItemList))[i];
									sprintf(str, "%s", pStr255);
									JSONNODE *json_text = json_new(JSON_STRING);
									json_set_text(json_text, str);
									json_push_back(json_scanner_option_values, json_text);
								}
									break;
									//					case TWTY_STR1024:
									//					case TWTY_UNI512:
									//						break;
								default:
									break;
							}
						}
						DSM::Unlock(tw_capability.hContainer);
						DSM::Free(tw_capability.hContainer);
					}
						break;
					case TWON_RANGE:
					{
						pTW_RANGE p = (pTW_RANGE)DSM::Lock(tw_capability.hContainer);
						json_set_i(json_scanner_option, L"type", p->ItemType);
						json_set_i(json_scanner_option, L"MinValue", p->MinValue);
						json_set_i(json_scanner_option, L"MaxValue", p->MaxValue);
						json_set_i(json_scanner_option, L"StepSize", p->StepSize);
						json_set_i(json_scanner_option, L"DefaultValue", p->DefaultValue);
						json_set_i(json_scanner_option, L"CurrentValue", p->CurrentValue);
						DSM::Unlock(tw_capability.hContainer);
						DSM::Free(tw_capability.hContainer);
					}
						break;
					case TWON_ONEVALUE:
					{
						pTW_ONEVALUE p = (pTW_ONEVALUE)DSM::Lock(tw_capability.hContainer);
						json_set_i(json_scanner_option, L"type", p->ItemType);
						DSM::Unlock(tw_capability.hContainer);
						DSM::Free(tw_capability.hContainer);
					}
						break;
				}
			}
			
			tw_capability.ConType = TWON_ONEVALUE;
			tw_capability.hContainer = 0;
			
			if(TWRC_SUCCESS == DSM_Entry(
																	 &DSM::tw_identity,
																	 &DSM::tw_source,
																	 DG_CONTROL,
																	 DAT_CAPABILITY,
																	 MSG_GET,
																	 (TW_MEMREF)&tw_capability))
			{
				pTW_ONEVALUE p = (pTW_ONEVALUE)DSM::Lock(tw_capability.hContainer);
				getCapabilityValueString(&tw_capability, p, returnValue);
				DSM::Unlock(tw_capability.hContainer);
				DSM::Free(tw_capability.hContainer);
			}
				Param3.appendUTF16String(returnValue.getUTF16StringPtr(), returnValue.getUTF16Length());
			json_push_back(json_scanner_options, json_scanner_option);
		}
	}
	
	void getOptionValues(C_TEXT &Param1, ARRAY_TEXT &Param2, ARRAY_TEXT &Param3)
	{
		Param2.setSize(1);
		Param3.setSize(1);
		
		JSONNODE *json_scanner_options = json_new(JSON_ARRAY);
	
		if(DSM::tw_state > DSM_STATE_NO_SOURCE)
		{
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_XFERCOUNT);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_COMPRESSION);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_PIXELTYPE);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_UNITS);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_XFERMECH);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_AUTHOR);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_CAPTION);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_FEEDERENABLED);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_FEEDERLOADED);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_TIMEDATE);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_SUPPORTEDCAPS);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_EXTENDEDCAPS);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_AUTOFEED);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_CLEARPAGE);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_FEEDPAGE);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_REWINDPAGE);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_INDICATORS);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_SUPPORTEDCAPSEXT);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_PAPERDETECTABLE);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_UICONTROLLABLE);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_DEVICEONLINE);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_AUTOSCAN);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_THUMBNAILSENABLED);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_DUPLEX);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_DUPLEXENABLED);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_ENABLEDSUIONLY);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_CUSTOMDSDATA);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_ENDORSER);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_JOBCONTROL);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_ALARMS);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_ALARMVOLUME);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_AUTOMATICCAPTURE);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_TIMEBEFOREFIRSTCAPTURE);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_TIMEBETWEENCAPTURES);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_CLEARBUFFERS);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_MAXBATCHBUFFERS);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_DEVICETIMEDATE);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_POWERSUPPLY);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_CAMERAPREVIEWUI);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_DEVICEEVENT);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_SERIALNUMBER);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_PRINTER);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_PRINTERENABLED);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_PRINTERINDEX);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_PRINTERMODE);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_PRINTERSTRING);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_PRINTERSUFFIX);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_LANGUAGE);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_FEEDERALIGNMENT);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_FEEDERORDER);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_REACQUIREALLOWED);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_BATTERYMINUTES);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, CAP_BATTERYPERCENTAGE);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_AUTOBRIGHT);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_BRIGHTNESS);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_CONTRAST);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_CUSTHALFTONE);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_EXPOSURETIME);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_FILTER);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_FLASHUSED);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_GAMMA);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_HALFTONES);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_HIGHLIGHT);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_IMAGEFILEFORMAT);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_LAMPSTATE);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_LIGHTSOURCE);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_ORIENTATION);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_PHYSICALWIDTH);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_PHYSICALHEIGHT);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_SHADOW);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_FRAMES);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_XNATIVERESOLUTION);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_YNATIVERESOLUTION);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_XRESOLUTION);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_YRESOLUTION);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_MAXFRAMES);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_TILES);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_BITORDER);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_CCITTKFACTOR);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_LIGHTPATH);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_PIXELFLAVOR);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_PLANARCHUNKY);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_ROTATION);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_SUPPORTEDSIZES);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_THRESHOLD);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_XSCALING);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_YSCALING);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_BITORDERCODES);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_PIXELFLAVORCODES);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_JPEGPIXELTYPE);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_TIMEFILL);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_BITDEPTH);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_BITDEPTHREDUCTION);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_UNDEFINEDIMAGESIZE);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_IMAGEDATASET);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_EXTIMAGEINFO);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_MINIMUMHEIGHT);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_MINIMUMWIDTH);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_FLIPROTATION);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_BARCODEDETECTIONENABLED);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_SUPPORTEDBARCODETYPES);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_BARCODEMAXSEARCHPRIORITIES);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_BARCODESEARCHPRIORITIES);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_BARCODESEARCHMODE);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_BARCODEMAXRETRIES);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_BARCODETIMEOUT);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_ZOOMFACTOR);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_PATCHCODEDETECTIONENABLED);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_SUPPORTEDPATCHCODETYPES);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_PATCHCODEMAXSEARCHPRIORITIES);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_PATCHCODESEARCHPRIORITIES);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_PATCHCODESEARCHMODE);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_PATCHCODEMAXRETRIES);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_PATCHCODETIMEOUT);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_FLASHUSED2);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_IMAGEFILTER);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_NOISEFILTER);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_OVERSCAN);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_AUTOMATICBORDERDETECTION);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_AUTOMATICDESKEW);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_AUTOMATICROTATE);
			getOptionValue(json_scanner_options, &DSM::tw_source, Param2, Param3, ICAP_JPEGQUALITY);
			
		}
		
		CUTF16String json;
		json_stringify(json_scanner_options, json);
		json_delete(json_scanner_options);
		
		Param2.setUTF16StringAtIndex(&json, 0);
	}
 
#pragma mark Transfer
	
	TW_UINT16 getImageInfo(TW_IDENTITY *source, TW_IMAGEINFO *imageinfo)
	{
		return DSM_Entry(
										 &DSM::tw_identity,
										 source,
										 DG_IMAGE,
										 DAT_IMAGEINFO,
										 MSG_GET,
										 (TW_MEMREF)imageinfo);
	}
	
	TW_UINT16 endTransfer(TW_IDENTITY *source, TW_PENDINGXFERS *pendingxfers)
	{
		return DSM_Entry(
										 &DSM::tw_identity,
										 source,
										 DG_CONTROL,
										 DAT_PENDINGXFERS,
										 MSG_ENDXFER,
										 (TW_MEMREF)pendingxfers);
	}
	
	TW_UINT16 initTransfer(TW_IDENTITY *source, TW_SETUPMEMXFER *setupmemxfer)
	{
		return DSM_Entry(
										 &DSM::tw_identity,
										 source,
										 DG_CONTROL,
										 DAT_SETUPMEMXFER,
										 MSG_GET,
										 (TW_MEMREF)setupmemxfer);
	}
	
	TW_UINT16 abortTransfer()//MSG_ENDXFER+MSG_RESET
	{
		TW_PENDINGXFERS tw_pendxfers;
		memset(&tw_pendxfers, 0, sizeof(TW_PENDINGXFERS));
		
		TW_UINT16 ret = DSM_Entry(
															&DSM::tw_identity,
															0,
															DG_CONTROL,
															DAT_PENDINGXFERS,
															MSG_ENDXFER,
															(TW_MEMREF)&tw_pendxfers);
		
		if(0 != tw_pendxfers.Count)
		{
			memset(&tw_pendxfers, 0, sizeof(TW_PENDINGXFERS));
			
			ret = DSM_Entry(
											&DSM::tw_identity,
											0,
											DG_CONTROL,
											DAT_PENDINGXFERS,
											MSG_RESET,
											(TW_MEMREF)&tw_pendxfers);
		}
		
		DSM::tw_state = DSM_STATE_NOT_READY;
		
		return ret;
	}
	
	void startTransfer(sLONG_PTR *pResult, PackagePtr pParams)
	{
		C_TEXT Param1;
		C_LONGINT Param2;
		C_TEXT Param3;
		C_TEXT Param5;

		Param1.fromParamAtIndex(pParams, 1);
		Param2.fromParamAtIndex(pParams, 2);
		Param3.fromParamAtIndex(pParams, 3);//callback method for results
		PA_Unistring *Param4 = (PA_Unistring *)(pParams[3]);//userInfo
		Param5.fromParamAtIndex(pParams, 5);//callback method for progress
		
		if(DSM::tw_state < DSM_STATE_NOT_READY)//<5
		{
			enableSource(&DSM::tw_source);//=5
			
			if(DSM::tw_state > DSM_STATE_NOT_ENABLED)//>4
			{
				TW_EVENT tw_event;
				memset(&tw_event, 0, sizeof(TW_EVENT));
				
				if(TWRC_DSEVENT == processEvent(&DSM::tw_source, &tw_event))
				{
					if(MSG_XFERREADY == tw_event.TWMessage)
					{
						//callback context
						image_type_t image_type = (image_type_t)Param2.getIntValue();
						bool use_callback_method = (Param3.getUTF16Length() != 0);
						PA_long32 method_id = PA_GetMethodID((PA_Unichar *)Param3.getUTF16StringPtr());
						bool use_progress_method = (Param5.getUTF16Length() != 0);
						PA_long32 progress_method_id = PA_GetMethodID((PA_Unichar *)Param5.getUTF16StringPtr());
						
						//scan context
						TW_SETUPMEMXFER tw_setup_mem_xfer;
						TW_IMAGEMEMXFER tw_image_mem_xfer;
						TW_IMAGEMEMXFER image_mem_xfer_template;
						TW_IMAGEINFO tw_imageinfo;
						
						int dpi_x;
						int dpi_y;
						int depth;
						int lines;
						int accumulated_lines;
						int accumulated_bytes;
						int pixels_per_line;
						int bytes_per_line;
						J_COLOR_SPACE jpg_color_space;
						int png_color_type;
						
						bool pending_xfers = true;
						
						while(pending_xfers)
						{
							PA_YieldAbsolute();
							
							C_BLOB data;
							//reset for each image
							memset(&tw_imageinfo, 0, sizeof(TW_IMAGEINFO));
							TW_UINT16 image_info_status = getImageInfo(&DSM::tw_source, &tw_imageinfo);
							
							if(image_info_status == TWRC_SUCCESS)
							{
								dpi_x = tw_imageinfo.XResolution.Whole;
								dpi_y = tw_imageinfo.YResolution.Whole;
								depth = tw_imageinfo.BitsPerPixel;
								lines = tw_imageinfo.ImageLength;
								
								accumulated_lines = 0;//in case lines = -1
								accumulated_bytes = 0;//for debug
								pixels_per_line = tw_imageinfo.ImageWidth;
								bytes_per_line = (((tw_imageinfo.ImageWidth * tw_imageinfo.BitsPerPixel)+7)/8);
								
								switch(tw_imageinfo.PixelType)
								{
									case TWPT_BW:
									case TWPT_GRAY:
										jpg_color_space = JCS_GRAYSCALE;
										png_color_type = PNG_COLOR_TYPE_GRAY;
										depth = tw_imageinfo.BitsPerPixel;
										break;
									case TWPT_RGB:
										jpg_color_space = JCS_RGB;
										png_color_type = PNG_COLOR_TYPE_RGB;
										depth = tw_imageinfo.BitsPerPixel / 3;
										break;
									default:
										//maybe later...
										//#define TWPT_BW
										//#define TWPT_GRAY
										//#define TWPT_RGB
										//#define TWPT_PALETTE
										//#define TWPT_CMY
										//#define TWPT_CMYK
										//#define TWPT_YUV
										//#define TWPT_YUVK
										//#define TWPT_CIEXYZ
										jpg_color_space = JCS_UNKNOWN;
										png_color_type = PNG_COLOR_TYPE_UNKNOWN;
										break;
								}
								
								bool incremental_image_generation = false;
								//incremental_image_generation not supported
								
								memset(&tw_setup_mem_xfer, 0, sizeof(TW_SETUPMEMXFER));
								TW_UINT16 mem_xfer_status = initTransfer(&DSM::tw_source, &tw_setup_mem_xfer);
								
								if(mem_xfer_status == TWRC_SUCCESS)
								{
									//setup buffer
									memset(&image_mem_xfer_template, 0, sizeof(TW_IMAGEMEMXFER));
									image_mem_xfer_template.Compression = TWON_DONTCARE16;
									image_mem_xfer_template.BytesPerRow = TWON_DONTCARE32;
									image_mem_xfer_template.Columns = TWON_DONTCARE32;
									image_mem_xfer_template.Rows = TWON_DONTCARE32;
									image_mem_xfer_template.XOffset = TWON_DONTCARE32;
									image_mem_xfer_template.YOffset = TWON_DONTCARE32;
									image_mem_xfer_template.BytesWritten = TWON_DONTCARE32;
									image_mem_xfer_template.Memory.Flags = TWMF_APPOWNS | TWMF_POINTER;
									image_mem_xfer_template.Memory.Length = tw_setup_mem_xfer.Preferred;
									
									TW_HANDLE hMem = (TW_HANDLE)DSM::Alloc(tw_setup_mem_xfer.Preferred);
									
									if(!hMem) break;//(while)
									
									image_mem_xfer_template.Memory.TheMem = DSM::Lock(hMem);
									
									bool scan_started = false;
									//this is the real buffer
									memset(&tw_image_mem_xfer, 0, sizeof(TW_IMAGEMEMXFER));
									
									
									//repeat on scan lines
									TW_UINT16 image_mem_xfer_status;
									
									for (;;)
									{
										PA_YieldAbsolute();
										
										memcpy(&tw_image_mem_xfer, &image_mem_xfer_template, sizeof(TW_IMAGEMEMXFER));
										memset( tw_image_mem_xfer.Memory.TheMem, 0, tw_image_mem_xfer.Memory.Length);
										
										image_mem_xfer_status = DSM_Entry(
																											&DSM::tw_identity,
																											&DSM::tw_source,
																											DG_IMAGE,
																											DAT_IMAGEMEMXFER,
																											MSG_GET,
																											(TW_MEMREF)&tw_image_mem_xfer);
										
										if((image_mem_xfer_status == TWRC_SUCCESS) || (image_mem_xfer_status == TWRC_XFERDONE))
										{
											accumulated_lines += tw_image_mem_xfer.Rows;
											accumulated_bytes = tw_image_mem_xfer.BytesWritten;
											
											if(!scan_started)
											{
												//start of image
												scan_started = true;
												if(incremental_image_generation)
												{
													//TODO:incremental_image_generation (header)
												}
											}//!scan_started
											
											if(tw_image_mem_xfer.Memory.Length)
											{
												if(incremental_image_generation)
												{
													//TODO:incremental_image_generation (body)
												}else
												{
													const uint8_t *p = reinterpret_cast<const uint8_t *>(tw_image_mem_xfer.Memory.TheMem);
													data.addBytes(p, tw_image_mem_xfer.BytesWritten);
													/*
													 for(int x = 0; x < tw_image_mem_xfer.Rows; ++x)
													 {
													 data.addBytes(p,  tw_image_mem_xfer.BytesPerRow);
													 p += tw_image_mem_xfer.BytesPerRow;
													 }
													 */
												}
											}
											
											if(use_progress_method)
											{
												CUTF16String progress_object;
												JSONNODE *json_progress = json_new(JSON_NODE);
												
												//progress information
												json_set_i(json_progress, L"XOffset", tw_image_mem_xfer.XOffset);
												json_set_i(json_progress, L"YOffset", tw_image_mem_xfer.YOffset);
												json_set_i(json_progress, L"Rows", tw_image_mem_xfer.Rows);
												json_set_i(json_progress, L"Columns", tw_image_mem_xfer.Columns);
												json_set_i(json_progress, L"BytesPerRow", tw_image_mem_xfer.BytesPerRow);
												json_set_i(json_progress, L"BytesWritten", tw_image_mem_xfer.BytesWritten);
												json_set_f(json_progress, L"XResolution", float(tw_imageinfo.XResolution.Whole) + float(tw_imageinfo.XResolution.Frac / 65536.0));
												json_set_f(json_progress, L"YResolution", float(tw_imageinfo.YResolution.Whole) + float(tw_imageinfo.YResolution.Frac / 65536.0));
												json_set_i(json_progress, L"SamplesPerPixel", tw_imageinfo.SamplesPerPixel);
												json_set_i(json_progress, L"PixelType", tw_imageinfo.PixelType);
												json_set_i(json_progress, L"ImageWidth", tw_imageinfo.ImageWidth);
												json_set_i(json_progress, L"ImageLength", tw_imageinfo.ImageLength);
												json_set_i(json_progress, L"BitsPerPixel", tw_imageinfo.BitsPerPixel);
												json_stringify(json_progress, progress_object);
												
												if((progress_method_id) && (!PA_IsProcessDying()))
												{
													PA_Variable	params[1];
													params[0] = PA_CreateVariable(eVK_Unistring);
													PA_Unistring u = PA_CreateUnistring((PA_Unichar *)progress_object.c_str());
													PA_SetStringVariable(&params[0], &u);
													PA_Variable statusCode = PA_ExecuteMethodByID(progress_method_id, params, 1);
													if((PA_GetVariableKind(statusCode) == eVK_Boolean) && PA_GetBooleanVariable(statusCode))
													{
														image_mem_xfer_status = TWRC_CANCEL;
													}
													PA_ClearVariable(&params[0]);
												}else if(!PA_IsProcessDying())
												{
													//maybe component method
													PA_Variable	params[3];
													params[0] = PA_CreateVariable(eVK_Unistring);
													PA_Unistring _methodName = PA_CreateUnistring((PA_Unichar *)Param5.getUTF16StringPtr());
													PA_SetStringVariable(&params[0], &_methodName);
													params[1] = PA_CreateVariable(eVK_Boolean);
													PA_SetBooleanVariable(&params[1], false);
													params[2] = PA_CreateVariable(eVK_Unistring);
													PA_Unistring u = PA_CreateUnistring((PA_Unichar *)progress_object.c_str());
													PA_SetStringVariable(&params[2], &u);
													PA_ExecuteCommandByID(1007, params, 3);
													if(PA_GetBooleanVariable(params[1]))
													{
														image_mem_xfer_status = TWRC_CANCEL;
													}
													PA_ClearVariable(&params[0]);
													PA_ClearVariable(&params[1]);
													PA_ClearVariable(&params[2]);
												}
											}
											
											if(image_mem_xfer_status == TWRC_XFERDONE)
											{
												PA_Picture picture;
												
												if(!incremental_image_generation)
												{
													if(lines == -1)
													{
														lines = accumulated_lines;
													}
													
													pixels_per_line = tw_image_mem_xfer.Columns;
													bytes_per_line = tw_image_mem_xfer.BytesPerRow;
													
													int logical_size =  tw_image_mem_xfer.BytesPerRow * lines;
													int actual_size = data.getBytesLength();
													
													if(logical_size > actual_size)
													{
														int padding = logical_size - actual_size;
														std::vector<uint8_t>buf(padding);
														memset(&buf[0], 0xFF, padding);
														data.addBytes(&buf[0],  padding);
													}
													if((jpg_color_space == JCS_GRAYSCALE) || (jpg_color_space = JCS_RGB))
													{
														switch (image_type)
														{
															case image_type_jpg:
															{
																picture = JPG::write_data(
																													data,
																													pixels_per_line,
																													lines,
																													depth,
																													bytes_per_line,
																													jpg_color_space,
																													dpi_x,
																													dpi_y);
															}
																break;
															case image_type_png:
															{
																picture = PNG::write_data(
																													data,
																													pixels_per_line,
																													lines,
																													depth,
																													bytes_per_line,
																													png_color_type,
																													dpi_x,
																													dpi_y);
															}
																break;
														}//switch
														
														if(use_callback_method)
														{
															if((method_id) && (!PA_IsProcessDying()))
															{
																PA_Variable	params[2];
																params[0] = PA_CreateVariable(eVK_Picture);
																PA_SetPictureVariable(&params[0], picture);
																params[1] = PA_CreateVariable(eVK_Unistring);
																PA_SetStringVariable(&params[1], Param4);
																PA_Variable statusCode = PA_ExecuteMethodByID(method_id, params, 2);
																if((PA_GetVariableKind(statusCode) == eVK_Boolean) && PA_GetBooleanVariable(statusCode))
																{
																	image_mem_xfer_status = TWRC_CANCEL;
																}
																PA_ClearVariable(&params[0]);
																PA_ClearVariable(&params[1]);
															}else if(!PA_IsProcessDying())
															{
																//maybe component method
																PA_Variable	params[4];
																params[0] = PA_CreateVariable(eVK_Unistring);
																PA_Unistring _methodName = PA_CreateUnistring((PA_Unichar *)Param3.getUTF16StringPtr());
																PA_SetStringVariable(&params[0], &_methodName);
																params[1] = PA_CreateVariable(eVK_Boolean);
																PA_SetBooleanVariable(&params[1], false);
																params[2] = PA_CreateVariable(eVK_Picture);
																PA_SetPictureVariable(&params[2], picture);
																params[3] = PA_CreateVariable(eVK_Unistring);
																PA_SetStringVariable(&params[3], Param4);
																PA_ExecuteCommandByID(1007, params, 4);
																if(PA_GetBooleanVariable(params[1]))
																{
																	image_mem_xfer_status = TWRC_CANCEL;
																}
																PA_ClearVariable(&params[0]);
																PA_ClearVariable(&params[1]);
																PA_ClearVariable(&params[2]);
																PA_ClearVariable(&params[3]);
															}
														}else
														{
															*(PA_Picture *) pResult = picture;
															image_mem_xfer_status = TWRC_CANCEL;//break after 1st image
														}
													}
												}
												
												break;//for()
												
											}else if((image_mem_xfer_status == TWRC_CANCEL) || (image_mem_xfer_status == TWRC_FAILURE))
											{
												break;//for()
											}
										}
									}
									
									DSM::Unlock(hMem);
									DSM::Free(hMem);
									
									if(TWRC_XFERDONE != image_mem_xfer_status) break;//while()
									
									//update pending_xfers
									TW_PENDINGXFERS tw_pendingxfers;
									memset(&tw_pendingxfers, 0, sizeof(TW_PENDINGXFERS));
									
									TW_UINT16 pending_xfer_status = endTransfer(&DSM::tw_source, &tw_pendingxfers);
									
									if(TWRC_SUCCESS == pending_xfer_status)
									{
										if(0 == tw_pendingxfers.Count)
										{
											pending_xfers = false;//no more images
										}//else more images
									}else
									{
										pending_xfers = false;//aborted
									}
									
								}else
								{
									break;//(while)
								}
							}else
							{
								break;//(while)
							}
							
						}//while
						
						if(pending_xfers == true)//broken from while loop
						{
							abortTransfer();
						}
					}
				}//processEvent
				
				
				disableSource(&DSM::tw_source);//=4
			}
			
		}
		
		
	}
	
	
	void openSession(C_TEXT& Param1)
	{
		//openManager -> getSource -> openSource
		if(DSM::tw_state < DSM_STATE_NO_SOURCE)//<2
		{
			openManager();//=2
		}
		
		if(DSM::tw_state > DSM_STATE_NO_SESSION)//>1
		{
			if(DSM::tw_state < DSM_STATE_NOT_OPEN)//<3
			{
				memset(&DSM::tw_source, 0, sizeof(TW_IDENTITY));
				getSource(Param1, &DSM::tw_source);//=3
			}
			
			if(DSM::tw_state < DSM_STATE_NOT_ENABLED)//<4
			{
				openSource(&DSM::tw_source);//=4
			}

		}
	}
	
	void closeSession(C_TEXT& Param1)
	{
		//abortTransfer -> disableSource -> closeSource -> closeManager

		if(DSM::tw_state > DSM_STATE_NOT_READY)//>5
		{
			abortTransfer();//=5
		}
		
		if(DSM::tw_state > DSM_STATE_NOT_ENABLED)//>4
		{
			disableSource(&DSM::tw_source);//=4
		}
		
		if(DSM::tw_state > DSM_STATE_NO_SOURCE)//>2
		{
			closeSource(&DSM::tw_source);//=2
		}
		
		if(DSM::tw_state > DSM_STATE_NO_SESSION)//>1
		{
			closeManager();//=1
		}
		
	}
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;
		
		CommandDispatcher(pProcNum, pResult, pParams);
	}
	catch(...)
	{
		
	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
		case kInitPlugin :
		case kServerInitPlugin :
			TWAIN::copyIdentity(&DSM::tw_identity);
			break;
			
// --- TWAIN

		case 1 :
			TWAIN_SCANNERS_LIST(pResult, pParams);
			break;

		case 2 :
			TWAIN_Scan(pResult, pParams);
			break;

		case 3 :
			TWAIN_SCAN_OPTION_VALUES(pResult, pParams);
			break;

		case 4 :
			TWAIN_SET_SCAN_OPTION(pResult, pParams);
			break;

		case 5 :
			TWAIN_Get_scan_option(pResult, pParams);
			break;
			
		case 6 :
			TWAIN_OPEN_SCANNER_SESSION(pResult, pParams);
			break;
			
		case 7 :
			TWAIN_CLOSE_SCANNER_SESSION(pResult, pParams);
			break;
			
	}
}

// ------------------------------------- TWAIN ------------------------------------

#pragma mark List

void TWAIN_SCANNERS_LIST(sLONG_PTR *pResult, PackagePtr pParams)
{
	ARRAY_TEXT Param1;
	
	TWAIN::getSources(Param1);
	
	Param1.toParamAtIndex(pParams, 1);
}

#pragma mark Scan

void TWAIN_Scan(sLONG_PTR *pResult, PackagePtr pParams)
{
	TWAIN::startTransfer(pResult, pParams);
}

#pragma mark Options

void TWAIN_SCAN_OPTION_VALUES(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	ARRAY_TEXT Param2;
	ARRAY_TEXT Param3;
	
	Param1.fromParamAtIndex(pParams, 1);

	TWAIN::getOptionValues(Param1, Param2, Param3);
	
	Param2.toParamAtIndex(pParams, 2);
	Param3.toParamAtIndex(pParams, 3);
}

void TWAIN_SET_SCAN_OPTION(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);

	TW_UINT16 cap = getCapabilityFromString(Param2);
	
	if(cap)
	{
		TWAIN::setOption(cap, Param1, Param3);
	}
	
}

void TWAIN_Get_scan_option(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);

	TW_UINT16 cap = getCapabilityFromString(Param2);
	
	if(cap)
	{
		TWAIN::getOption(cap, Param1, returnValue);
	}
	
	returnValue.setReturn(pResult);
	
}

#pragma mark session

void TWAIN_OPEN_SCANNER_SESSION(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	TWAIN::openSession(Param1);
}

void TWAIN_CLOSE_SCANNER_SESSION(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	TWAIN::closeSession(Param1);
}
