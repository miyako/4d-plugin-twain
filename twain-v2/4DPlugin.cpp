/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : TWAIN
 #	author : miyako
 #	2017/11/27
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"


void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;
		
		CommandDispatcher(pProcNum, pResult, pParams);
	}
	catch(...)
	{
		
	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
			// --- TWAIN
			
		case 1 :
			TWAIN_SCANNERS_LIST(pResult, pParams);
			break;
			
		case 2 :
			TWAIN_Get_default_option(pResult, pParams);
			break;
			
		case 3 :
			TWAIN_SCAN(pResult, pParams);
			break;
			
	}
}

// ------------------------------------- TWAIN ------------------------------------

#pragma mark TWAIN

typedef struct
{
	TW_UINT16 majorNum;
	TW_UINT16 minorNum;
	TW_UINT16 language;
	TW_UINT16 country;
	TW_UINT16 format;
}twain_version_info_t;

void twain_generate_uuid_pair(std::wstring& ParamA, std::wstring& ParamB)
{
#if VERSIONWIN
	UUID uuid;
	RPC_WSTR flagPtr;
	if(UuidCreate(&uuid) == RPC_S_OK)
	{
		if(UuidToString(&uuid, &flagPtr) == RPC_S_OK)
		{
			ParamA = std::wstring((const wchar_t *)flagPtr, wcslen((const wchar_t *)flagPtr));
			RpcStringFree(&flagPtr);
			if(UuidCreate(&uuid) == RPC_S_OK)
			{
				if(UuidToString(&uuid, &flagPtr) == RPC_S_OK)
				{
					ParamB = std::wstring((const wchar_t *)flagPtr, wcslen((const wchar_t *)flagPtr));
					RpcStringFree(&flagPtr);
				}
			}
		}
	}
#endif
}

void twain_get_version_info(TW_UINT16 *MajorNum,
														TW_UINT16 *MinorNum,
														TW_UINT16 *Language,
														TW_UINT16 *Country)
{
	PA_Variable args[1];
	args[0] = PA_CreateVariable(eVK_Longint);
	PA_SetLongintVariable(&args[0], 0);
	PA_Unistring ret = PA_GetStringVariable(PA_ExecuteCommandByID(CMD_Get_database_localization , args, 1));
	if(!PA_CompareUniBuffers(ret.fString, ret.fLength, (PA_Unichar *)"j\0a\0@\0\0\0", 3, 0, 1))
	{
		*Language = TWLG_JAPANESE;
		*Country = TWCY_JAPAN;
		goto clear;
	}
	if(!PA_CompareUniBuffers(ret.fString, ret.fLength, (PA_Unichar *)"f\0r\0@\0\0\0", 3, 0, 1))
	{
		*Language = TWLG_FRENCH;
		*Country = TWCY_FRANCE;
		goto clear;
	}
	if(!PA_CompareUniBuffers(ret.fString, ret.fLength, (PA_Unichar *)"d\0e\0@\0\0\0", 3, 0, 1))
	{
		*Language = TWLG_GERMAN;
		*Country = TWCY_GERMANY;
		goto clear;
	}
	if(!PA_CompareUniBuffers(ret.fString, ret.fLength, (PA_Unichar *)"e\0s\0@\0\0\0", 3, 0, 1))
	{
		*Language = TWLG_SPANISH;
		*Country = TWCY_SPAIN;
		goto clear;
	}
	if(!PA_CompareUniBuffers(ret.fString, ret.fLength, (PA_Unichar *)"p\0t\0@\0\0\0", 3, 0, 1))
	{
		*Language = TWLG_PORTUGUESE;
		*Country = TWCY_BRAZIL;
		goto clear;
	}
	*Language = TWLG_ENGLISH;
	*Country = TWCY_USA;
clear:
	PA_ClearVariable(&args[0]);
	
	PA_ulong32 version = PA_Get4DVersion();
	*MajorNum = (version & 0x0000FF00) >> 8;
	*MinorNum = (version & 0x000000FF);
}

void twain_get_option_param(TW_IDENTITY *tw_identity,
														TW_IDENTITY *tw_source_identity,
														TW_CAPABILITY *tw_capability,
														void *_entrypoint,
														JSONNODE *json_scanner_option_values)
{
	
#if USE_TWAIN_DSM
	TW_ENTRYPOINT *tw_entrypoint = (TW_ENTRYPOINT *)_entrypoint;
#else
	void *tw_entrypoint = 0;
#endif
	
	std::wstring optionName;
	twain_get_capability_option_name(tw_capability->Cap, optionName);
	
	/* name */
	JSONNODE *json_scanner_option = json_new(JSON_NODE);
	json_set_name(json_scanner_option, optionName.c_str());
	
	tw_capability->ConType = 0;
	tw_capability->hContainer = 0;
	
	if(TWRC_SUCCESS == DSM_Entry(
															 tw_identity,
															 tw_source_identity,
															 DG_CONTROL,
															 DAT_CAPABILITY,
															 MSG_GET,
															 (TW_MEMREF)tw_capability))
	{
		twain_get_capability_param(tw_capability,
															 DSM::Lock(tw_entrypoint, tw_capability->hContainer),
															 json_scanner_option);
		
		DSM::Unlock(tw_entrypoint, tw_capability->hContainer);
		DSM::Free(tw_entrypoint, tw_capability->hContainer);
	}
	
	json_push_back(json_scanner_option_values, json_scanner_option);
}

#pragma mark -

void get_json_from_utf16_data(C_TEXT& t, unsigned char **p, uint32_t *totalsize)
{
	uint32_t outbuffersize = 0;
	memcpy(&outbuffersize, *p, sizeof(outbuffersize));
	*p += sizeof(outbuffersize);
	std::vector<uint8_t>buf(outbuffersize);
	memcpy(&buf[0], *p, outbuffersize);
	CUTF16String json = CUTF16String((const PA_Unichar *)&buf[0], outbuffersize/sizeof(PA_Unichar));
	t.setUTF16String(&json);
	*p += outbuffersize;
	*totalsize += sizeof(outbuffersize);
	*totalsize += outbuffersize;
}

#pragma mark Threads

#if VERSIONWIN

HANDLE createFmIn1(C_TEXT& Param1_scanner, C_TEXT& Param2_option,
									 std::wstring& ParamA,
									 std::wstring& ParamB,
									 DWORD *ParamA_len,
									 DWORD *ParamB_len,
									 DWORD *Param1_len,
									 DWORD *Param2_len)
{
	CUTF8String scanner;
	Param1_scanner.copyUTF8String(&scanner);
	
	CUTF8String option;
	Param2_option.copyUTF8String(&option);
	
	*ParamA_len = ParamA.length() * sizeof(wchar_t);
	*ParamB_len = ParamB.length() * sizeof(wchar_t);
	*Param1_len = scanner.length();
	*Param2_len = option.length();
	
	DWORD len = (sizeof(DWORD)*4)
	+ (*ParamA_len) + (*ParamB_len)
	+ (*Param1_len) + (*Param2_len);
	
	BOOL success = FALSE;
	
	HANDLE fmIn = CreateFileMapping(
																	INVALID_HANDLE_VALUE,
																	NULL,
																	PAGE_READWRITE,
																	0, len,
																	L"TWAIN_PARAM_IN");
	if(fmIn)
	{
		LPVOID bufIn = MapViewOfFile(fmIn,
																 FILE_MAP_WRITE,
																 0,
																 0, len);
		if(bufIn)
		{
			try
			{
				unsigned char *p = (unsigned char *)bufIn;
				
				CopyMemory(p, ParamA_len, sizeof(DWORD));
				p += sizeof(DWORD);
				CopyMemory(p, ParamB_len, sizeof(DWORD));
				p += sizeof(DWORD);
				
				CopyMemory(p, Param1_len, sizeof(DWORD));
				p += sizeof(DWORD);
				CopyMemory(p, Param2_len, sizeof(DWORD));
				p += sizeof(DWORD);
				
				CopyMemory(p, ParamA.c_str(), *ParamA_len);
				p += (*ParamA_len);
				CopyMemory(p, ParamB.c_str(), *ParamB_len);
				p += (*ParamB_len);
				
				CopyMemory(p, scanner.c_str(), *Param1_len);
				p += (*Param1_len);
				CopyMemory(p, option.c_str(), *Param2_len);
				
				success = TRUE;
			}
			catch(...)
			{
				/* CopyMemory() failed */
			}
			UnmapViewOfFile(bufIn);
		}//bufIn
		if(!success)
		{
			CloseHandle(fmIn);
			return 0;
		}
		
	}
	
	return fmIn;
}

HANDLE createFmIn2(DWORD *ParamA_len,
									 DWORD *ParamB_len,
									 DWORD *Param1_len,
									 DWORD *Param2_len)
{
	/*
	 * Param1:scanner
	 * Param2:data
	 */
	
	BOOL success = FALSE;
	
	*ParamA_len = 0;
	*ParamB_len = 0;
	*Param1_len = 0;
	*Param2_len = 0;
	
	DWORD len = (sizeof(DWORD)*4);
	
	HANDLE fmIn = CreateFileMapping(
																	INVALID_HANDLE_VALUE,
																	NULL,
																	PAGE_READWRITE,
																	0, len,
																	L"TWAIN_PARAM_IN");
	if (fmIn)
	{
		LPVOID bufIn = MapViewOfFile(fmIn, FILE_MAP_READ, 0, 0, len);
		if (bufIn)
		{
			unsigned char *p = (unsigned char *)bufIn;
			try
			{
				CopyMemory(ParamA_len, p, sizeof(DWORD));
				p += sizeof(DWORD);
				CopyMemory(ParamB_len, p, sizeof(DWORD));
				p += sizeof(DWORD);
				CopyMemory(Param1_len, p, sizeof(DWORD));
				p += sizeof(DWORD);
				CopyMemory(Param2_len, p, sizeof(DWORD));
				
				success = TRUE;
			}
			catch (...)
			{
				
			}
			UnmapViewOfFile(bufIn);
		}//bufIn
		CloseHandle(fmIn);
	}//fmIn
	
	if (success)
	{
		return CreateFileMapping(
														 INVALID_HANDLE_VALUE,
														 NULL,
														 PAGE_READWRITE,
														 0, len,
														 L"TWAIN_PARAM_IN");
	}
	
	return 0;
}

HANDLE createEventforBufIn2(LPVOID bufIn,
														DWORD ParamA_len,
														DWORD ParamB_len,
														DWORD Param1_len,
														DWORD Param2_len,
														std::wstring& ParamA,
														std::wstring& ParamB,
														C_TEXT& Param1_scanner,
														std::wstring& Param2_option)
{
	unsigned char *p = (unsigned char *)bufIn;
	p = p + (sizeof(DWORD)*4);
	
	std::vector<uint8_t>scanner(Param1_len);
	std::vector<uint8_t>option(Param2_len);
	
	std::vector<uint8_t>signalA(ParamA_len);
	std::vector<uint8_t>signalB(ParamB_len);
	
	if (ParamA_len)
	{
		CopyMemory(&signalA[0], p, ParamA_len);
		p += ParamA_len;
		ParamA = std::wstring((const wchar_t *)&signalA[0], ParamA_len / sizeof(wchar_t));
	}
	
	if (ParamB_len)
	{
		CopyMemory(&signalB[0], p, ParamB_len);
		p += ParamB_len;
		ParamB = std::wstring((const wchar_t *)&signalB[0], ParamB_len / sizeof(wchar_t));
	}
	
	if (Param1_len)
	{
		CopyMemory(&scanner[0], p, Param1_len);
		p += Param1_len;
		Param1_scanner.setUTF8String((const uint8_t *)&scanner[0], Param1_len);
	}
	
	if (Param2_len)
	{
		CopyMemory(&option[0], p, Param2_len);
		p += Param2_len;
		json_wconv((const char *)&option[0], Param2_option);
	}
	
	HANDLE scanEvent_c = CreateEvent(NULL, /* the handle cannot be inherited by child processes */
																	 TRUE, /* manual-reset event object */
																	 FALSE, /* initial state */
																	 ParamB.c_str());
	
	return scanEvent_c;
}

HANDLE createFmOut2(C_BLOB* data)
{
	DWORD data_len = data->getBytesLength();
	
	DWORD len = sizeof(DWORD) + data_len;
	
	HANDLE fmOut = CreateFileMapping(
																	 INVALID_HANDLE_VALUE,
																	 NULL,
																	 PAGE_READWRITE,
																	 0, len,
																	 L"TWAIN_PARAM_OUT");
	if (fmOut)
	{
		LPVOID bufOut = MapViewOfFile(fmOut, FILE_MAP_WRITE, 0, 0, len);
		if (bufOut)
		{
			unsigned char *p = (unsigned char *)bufOut;
			try
			{
				CopyMemory(p, &data_len, sizeof(DWORD));
				p += sizeof(DWORD);
				if (data_len)
				{
					CopyMemory(p, (void *)data->getBytesPtr(), data_len);
				}
			}
			catch (...)
			{
				
			}
			UnmapViewOfFile(bufOut);
		}//bufOut
		
	}
	
	return fmOut;
}


void getDataFromThread2(C_BLOB& data)
{
	DWORD data_len = 0;
	DWORD len = sizeof(DWORD);
	
	BOOL success = FALSE;
	
	HANDLE fmOut = CreateFileMapping(
																	 INVALID_HANDLE_VALUE,
																	 NULL,
																	 PAGE_READWRITE,
																	 0, len,
																	 L"TWAIN_PARAM_OUT");
	if (fmOut)
	{
		LPVOID bufOut = MapViewOfFile(fmOut, FILE_MAP_READ, 0, 0, len);
		if (bufOut)
		{
			unsigned char *p = (unsigned char *)bufOut;
			try
			{
				CopyMemory(&data_len, p, sizeof(DWORD));
				success = TRUE;
			}
			catch (...)
			{
				
			}
			UnmapViewOfFile(bufOut);
		}
		CloseHandle(fmOut);
	}
	if ((success) && (data_len))
	{
		len = len + data_len;
		
		fmOut = CreateFileMapping(
															INVALID_HANDLE_VALUE,
															NULL,
															PAGE_READWRITE,
															0, len,
															L"TWAIN_PARAM_OUT");
		if (fmOut)
		{
			LPVOID bufOut = MapViewOfFile(fmOut, FILE_MAP_READ, 0, 0, len);
			if (bufOut)
			{
				unsigned char *p = (unsigned char *)bufOut;
				p = p + sizeof(DWORD);
				try
				{
					std::vector<uint8_t>buf(data_len);
					CopyMemory(&buf[0], p, data_len);
					data.setBytes((const uint8_t *)&buf[0], data_len);
				}
				catch (...)
				{
					
				}
				UnmapViewOfFile(bufOut);
			}
			CloseHandle(fmOut);
		}
		
	}
	
}

void waitForEvent(HANDLE h, HANDLE scanEvent_p, C_BLOB& data, std::wstring& ParamB, DWORD len)
{
	BOOL exit = FALSE;
	do {
		switch (WaitForSingleObject(scanEvent_p, 100))
		{
			case WAIT_ABANDONED:
			case WAIT_FAILED:
				exit = TRUE;
				break;
			case WAIT_TIMEOUT:
				PA_YieldAbsolute();
				break;
			case WAIT_OBJECT_0:
				ResetEvent(scanEvent_p);
				BOOL success = FALSE;
				
				getDataFromThread2(data);
				
				HANDLE scanEvent_c = OpenEvent(EVENT_ALL_ACCESS, FALSE, ParamB.c_str());
				if(scanEvent_c)
				{
					/* tell c to die */
					SetEvent(scanEvent_c);
					CloseHandle(scanEvent_c);
				}
				
				do {
					switch (WaitForSingleObject(h, 100))
					{
						case WAIT_TIMEOUT:
							PA_YieldAbsolute();
							break;
						case WAIT_ABANDONED:
						case WAIT_FAILED:
						case WAIT_OBJECT_0:
							exit = TRUE;
							break;
					}
				} while (!exit);
				
				exit = TRUE;
				break;
		}
		
	} while (!exit);
}
#endif

#pragma mark -

void TWAIN_Get_default_option(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1_scanner;
	C_TEXT Param2_values;
	C_TEXT returnValue;

	Param1_scanner.fromParamAtIndex(pParams, 1);

	C_BLOB data;
	
	TW_UINT16 majorNum, minorNum, language, country;
	twain_get_version_info(&majorNum, &minorNum, &language, &country);
	
#if VERSIONWIN
	
	std::wstring ParamA;
	std::wstring ParamB;

	twain_generate_uuid_pair(ParamA, ParamB);

	DWORD ParamA_len = 0;
	DWORD ParamB_len = 0;
	DWORD Param1_len = 0;
	DWORD Param2_len = 0;
	
	HANDLE scanEvent_p = CreateEvent(NULL, /* the handle cannot be inherited by child processes */
																	 TRUE, /* creates a manual-reset event object */
																	 FALSE, /* initial state of the event object */
																	 ParamA.c_str());
	
	if(scanEvent_p)
	{
		C_TEXT Param2_option; /* not used */
		
		HANDLE fmIn = createFmIn1(Param1_scanner,
															Param2_option,
															ParamA,
															ParamB,
															&ParamA_len,
															&ParamB_len,
															&Param1_len,
															&Param2_len);
		if(fmIn)
		{
			twain_version_info_t version_info;
			version_info.majorNum = majorNum;
			version_info.minorNum = minorNum;
			version_info.language = language;
			version_info.country = country;
			
			HANDLE h = (HANDLE)_beginthreadex(NULL /* security: handle not inherited */,
																				0 /* stack size:default */,
																				getOptionWin,
																				&version_info /* arguments */,
																				0 /* init flags:execute immediately */,
																				NULL /* thread id */);
			if(h)
			{
				waitForEvent(h, scanEvent_p, data, ParamB, (sizeof(DWORD)*4) + ParamA_len + ParamB_len + Param1_len + Param2_len);

				CloseHandle(h);
			}//h

			CloseHandle(fmIn);
		}//fmIn
		CloseHandle(scanEvent_p);
	}//scanEvent_p
	
#else
	
	std::wstring Param2_option; /* not used */
	
	getOption(Param1_scanner, Param2_option, data,
						majorNum, minorNum, language, country);
	
#endif
	
	uint32_t data_len = data.getBytesLength();
	unsigned char *p = (unsigned char *)data.getBytesPtr();
	uint32_t totalsize = 0;
	
	if(totalsize < data_len)
	{
		get_json_from_utf16_data(returnValue, &p, &totalsize);
	}

	if(totalsize < data_len)
	{
		get_json_from_utf16_data(Param2_values, &p, &totalsize);
	}
	
	returnValue.setReturn(pResult);
	Param2_values.toParamAtIndex(pParams, 2);
}

void TWAIN_SCANNERS_LIST(sLONG_PTR *pResult, PackagePtr pParams)
{
	ARRAY_TEXT Param1_scanners;
	
	Param1_scanners.setSize(1);
	
	JSONNODE *json_scanners = json_new(JSON_ARRAY);
	
	TW_IDENTITY tw_identity;
	TW_USERINTERFACE tw_userinterface;
	HWND tw_parent = NULL;
	
#if USE_TWAIN_DSM
	TW_ENTRYPOINT tw_entrypoint;
#else
	void *tw_entrypoint;
#endif
	
	TW_UINT16 majorNum, minorNum, language, country;
	twain_get_version_info(&majorNum, &minorNum, &language, &country);
	twain_configure(&tw_identity, &tw_userinterface, &tw_entrypoint, &tw_parent, majorNum, minorNum, language, country);
	
	TW_UINT16 tw_ret = twain_dsm_open(&tw_identity, &tw_userinterface, &tw_entrypoint, &tw_parent);
	
	if(tw_ret == TWRC_SUCCESS)
	{
		std::vector<TW_IDENTITY>sources;
		
		twain_get_sources_list(&tw_identity, sources);
		
		for(std::vector<TW_IDENTITY>::iterator it = sources.begin(); it < sources.end(); it++)
		{
			TW_IDENTITY identity = *it;
			JSONNODE *json_scanner = json_new(JSON_NODE);
			json_set_s_for_key(json_scanner, L"Manufacturer", (char *)identity.Manufacturer);
			json_set_s_for_key(json_scanner, L"ProductFamily", (char *)identity.ProductFamily);
			json_set_s_for_key(json_scanner, L"ProductName", (char *)identity.ProductName);
			
			//Version
			JSONNODE *json_scanner_version = json_new(JSON_NODE);
			json_set_s_for_key(json_scanner_version, L"Info", (char *)identity.Version.Info);
			json_set_i_for_key(json_scanner_version, L"MajorNum", identity.Version.MajorNum);
			json_set_i_for_key(json_scanner_version, L"MinorNum", identity.Version.MinorNum);
			json_set_i_for_key(json_scanner_version, L"Language", identity.Version.Language);
			json_set_i_for_key(json_scanner_version, L"Country", identity.Version.Country);
			json_set_name(json_scanner_version, L"Version");
			json_push_back(json_scanner, json_scanner_version);
			
			json_set_i_for_key(json_scanner, L"ProtocolMajor", identity.ProtocolMajor);
			json_set_i_for_key(json_scanner, L"ProtocolMinor", identity.ProtocolMinor);
			json_set_i_for_key(json_scanner, L"SupportedGroups", identity.SupportedGroups);
			
			json_push_back(json_scanners, json_scanner);
			CUTF8String scanner = (const uint8_t *)identity.ProductName;
			Param1_scanners.appendUTF8String(&scanner);
		}
		
		tw_ret = twain_dsm_close(&tw_identity, &tw_parent);
	}
	
	//dump json in element #0
	CUTF16String json;
	json_stringify(json_scanners, json, FALSE);
	json_delete(json_scanners);
	
	Param1_scanners.setUTF16StringAtIndex(&json, 0);
	Param1_scanners.toParamAtIndex(pParams, 1);
}

void TWAIN_SCAN(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1_scanner;
	C_TEXT Param2_option;
	C_LONGINT Param3_format;

	Param1_scanner.fromParamAtIndex(pParams, 1);
	Param2_option.fromParamAtIndex(pParams, 2);
	Param3_format.fromParamAtIndex(pParams, 3);

	TW_UINT16 majorNum, minorNum, language, country;
	twain_get_version_info(&majorNum, &minorNum, &language, &country);
	
	int format;
	format = Param3_format.getIntValue();
	
	C_BLOB data;

#if VERSIONWIN
	
	std::wstring ParamA;
	std::wstring ParamB;
	
	twain_generate_uuid_pair(ParamA, ParamB);
	
	DWORD ParamA_len = 0;
	DWORD ParamB_len = 0;
	DWORD Param1_len = 0;
	DWORD Param2_len = 0;
	
	HANDLE scanEvent_p = CreateEvent(NULL, /* the handle cannot be inherited by child processes */
																	 TRUE, /* creates a manual-reset event object */
																	 FALSE, /* initial state of the event object */
																	 ParamA.c_str());
	
	if(scanEvent_p)
	{
		//C_TEXT Param2_option; /* not used */
		
		HANDLE fmIn = createFmIn1(Param1_scanner,
															Param2_option,
															ParamA,
															ParamB,
															&ParamA_len,
															&ParamB_len,
															&Param1_len,
															&Param2_len);
		if(fmIn)
		{
			twain_version_info_t version_info;
			version_info.majorNum = majorNum;
			version_info.minorNum = minorNum;
			version_info.language = language;
			version_info.country = country;
			version_info.format = format;
			
			HANDLE h = (HANDLE)_beginthreadex(NULL /* security: handle not inherited */,
																				0 /* stack size:default */,
																				doScanWin,
																				&version_info /* arguments */,
																				0 /* init flags:execute immediately */,
																				NULL /* thread id */);
			if(h)
			{
				waitForEvent(h, scanEvent_p, data, ParamB, (sizeof(DWORD)*4) + ParamA_len + ParamB_len + Param1_len + Param2_len);
				
				CloseHandle(h);
			}//h
			
			CloseHandle(fmIn);
		}//fmIn
		CloseHandle(scanEvent_p);
	}//scanEvent_p
	
#else
	
	CUTF8String option;
	Param2_option.copyUTF8String(&option);
	
	std::wstring _Param2_option;
	json_wconv((const char *)option.c_str(), _Param2_option);
	
	doScan(Param1_scanner,
				 _Param2_option,
				 data,
				 majorNum,
				 minorNum,
				 language,
				 country,
				 format);
	
#endif
	
	//$4
	PA_Variable Param4 = *((PA_Variable*) pParams[3]);
	switch (Param4.fType)
	{
		case eVK_ArrayPicture:
			PA_SetArrayCurrent(&Param4, 0);
			PA_ResizeArray(&Param4, 0);
			break;
		case eVK_Undefined:
			PA_ClearVariable(&Param4);
			Param4 = PA_CreateVariable(eVK_ArrayPicture);
			break;
		default:
			break;
	}
	
	size_t data_len = data.getBytesLength();
	unsigned char *p = (unsigned char *)data.getBytesPtr();
	size_t totalsize = 0;
	
	while (totalsize<data_len)
	{
		size_t outbuffersize = 0;
		memcpy(&outbuffersize, p, sizeof(outbuffersize));
		p += sizeof(outbuffersize);
		//->$4
		if(Param4.fType == eVK_ArrayPicture)
		{
			std::vector<uint8_t>buf(outbuffersize);
			memcpy(&buf[0], p, outbuffersize);
			if (format == 1)
			{
#define CMU_BLOB_TO_PICTURE 682

				PA_Variable args[3];
				args[0] = PA_CreateVariable(eVK_Blob);
				args[1] = PA_CreateVariable(eVK_Picture);
				args[2] = PA_CreateVariable(eVK_Unistring);
				PA_SetBlobVariable(&args[0], (void *)&buf[0], outbuffersize);
				PA_SetUnistring((&(args[2].uValue.fString)), (PA_Unichar *)"e\0n\0c\0a\0p\0s\0u\0l\0a\0t\0i\0o\0n\0\0\0");
				PA_ExecuteCommandByID(CMU_BLOB_TO_PICTURE, args, 3);
				PA_Picture picture = PA_DuplicatePicture(PA_GetPictureVariable(args[1]), 1);
				PA_ClearVariable(&args[1]);
				PA_long32 count = PA_GetArrayNbElements(Param4);
				count++;
				PA_ResizeArray(&Param4, count);
				PA_SetPictureInArray(Param4, count, picture);
			}
			else
			{
				PA_Picture picture = PA_CreatePicture((void *)&buf[0], outbuffersize);
				PA_long32 count = PA_GetArrayNbElements(Param4);
				count++;
				PA_ResizeArray(&Param4, count);
				PA_SetPictureInArray(Param4, count, picture);
			}

		}
		p += outbuffersize;
		totalsize += sizeof(outbuffersize);
		totalsize += outbuffersize;
	}
	
	//sync $4
	PA_Variable *pParam4 = ((PA_Variable *)pParams[3]);
	pParam4->fType = Param4.fType;
	pParam4->fFiller = Param4.fFiller;
	pParam4->uValue.fArray.fCurrent = Param4.uValue.fArray.fCurrent;
	pParam4->uValue.fArray.fNbElements = Param4.uValue.fArray.fNbElements;
	pParam4->uValue.fArray.fData = Param4.uValue.fArray.fData;
	PA_YieldAbsolute();
}

#pragma mark Scan

void doScan(C_TEXT &Param1_scanner,
						std::wstring& Param2_option,
						C_BLOB& picture,
						TW_UINT16 majorNum,
						TW_UINT16 minorNum,
						TW_UINT16 language,
						TW_UINT16 country,
						int Param3_format)
{
	JSONNODE *option = json_parse(Param2_option.c_str());
	
	TW_IDENTITY tw_identity;
	TW_USERINTERFACE tw_userinterface;
	HWND tw_parent = NULL;
	
#if USE_TWAIN_DSM
	TW_ENTRYPOINT tw_entrypoint;
#else
	void *tw_entrypoint;
#endif
	
	twain_configure(&tw_identity, &tw_userinterface, &tw_entrypoint, &tw_parent, majorNum, minorNum, language, country);
	
	TW_UINT16 tw_ret = twain_dsm_open(&tw_identity, &tw_userinterface, &tw_entrypoint, &tw_parent);
	if(tw_ret == TWRC_SUCCESS)
	{
		TW_IDENTITY tw_source_identity;
		tw_ret = twain_source_open(&tw_identity, &tw_source_identity, Param1_scanner);
		
		if(tw_ret == TWRC_SUCCESS)
		{
			if (option)
			{
				if (json_type(option) == JSON_NODE)
				{
					JSONNODE_ITERATOR i = json_begin(option);
					while (i != json_end(option))
					{
						if (*i)
						{
							TW_UINT16 cap = 0;
							json_char *name = json_name(*i);
							if (name)
							{
								cap = json_get_cap(name);
								json_free(name);
							}

							if (cap)
							{
								TW_CAPABILITY tw_capability;
								memset(&tw_capability, 0, sizeof(TW_CAPABILITY));

								tw_capability.Cap = cap;
								tw_capability.ConType = 0;
								tw_capability.hContainer = 0;

								/* find value type */

								if (TWRC_SUCCESS == DSM_Entry(
									&tw_identity,
									&tw_source_identity,
									DG_CONTROL,
									DAT_CAPABILITY,
									MSG_GET,
									(TW_MEMREF)&tw_capability))
								{
									TW_UINT16 itemType = 0;
									TW_UINT32 numItems = 0;
									TW_UINT32 contSize = 0;

									void *_p = DSM::Lock(&tw_entrypoint, tw_capability.hContainer);

									switch (tw_capability.ConType)
									{
									case TWON_ARRAY:

										break;
									case TWON_ENUMERATION:
										itemType = ((pTW_ENUMERATION)_p)->ItemType;
										numItems = ((pTW_ENUMERATION)_p)->NumItems;
										contSize = sizeof(TW_ENUMERATION) + (getSizeForItemType(itemType) * numItems);
										break;
									case TWON_ONEVALUE:
										itemType = ((pTW_ONEVALUE)_p)->ItemType;
										contSize = sizeof(TW_ONEVALUE);
										break;
									case TWON_RANGE:
										itemType = ((pTW_RANGE)_p)->ItemType;
										contSize = sizeof(TW_RANGE);
										break;
									}

									DSM::Unlock(&tw_entrypoint, tw_capability.hContainer);
									DSM::Free(&tw_entrypoint, tw_capability.hContainer);

									if (contSize)
									{
										tw_capability.hContainer = DSM::Alloc(&tw_entrypoint, contSize);

										void *p = DSM::Lock(&tw_entrypoint, tw_capability.hContainer);

										switch (tw_capability.ConType)
										{
										case TWON_ARRAY:

											break;
										case TWON_ENUMERATION:
											((pTW_ENUMERATION)p)->ItemType = itemType;
											((pTW_ENUMERATION)p)->NumItems = numItems;
											break;
										case TWON_ONEVALUE:
											((pTW_ONEVALUE)p)->ItemType = itemType;
											break;
										case TWON_RANGE:
											((pTW_RANGE)p)->ItemType = itemType;
											break;
										}

										pTW_ENUMERATION pENUMERATION = (pTW_ENUMERATION)p;
										pTW_ONEVALUE pONEVALUE = (pTW_ONEVALUE)p;
										pTW_RANGE pRANGE = (pTW_RANGE)p;

										double f_value = json_as_float(*i);
										TW_BOOL b_value = json_as_bool(*i);
										int i_value = json_get_cap_constant(*i, cap);
										i_value = i_value ? i_value : json_as_int(*i);

										switch (tw_capability.ConType)
										{
										case TWON_ARRAY:

											break;

										case TWON_ENUMERATION:
											for (int i = 0; i < pENUMERATION->NumItems; ++i)
											{
												if (i_value == (pENUMERATION->ItemList)[i])
												{
													pENUMERATION->CurrentIndex = i;
													break;
												}
											}
											break;

										case TWON_ONEVALUE:
											switch (pONEVALUE->ItemType)
											{
											case TWTY_FIX32:
											{
												TW_INT32 value = (TW_INT32)(f_value * 65536.0 + ((f_value < 0) ? (-0.5) : 0.5));
												TW_FIX32 tw_fix32;
												tw_fix32.Whole = (TW_UINT16)(value >> 16);
												tw_fix32.Frac = (TW_UINT16)(value & 0x0000ffffL);
												memcpy((void *)&pONEVALUE->Item, (const void *)&tw_fix32, sizeof(TW_FIX32));
											}
											break;
											case TWTY_FRAME:
											{
												//not implemented!
											}
											break;
											case TWTY_INT8:
											{
												TW_INT8 tw_int8 = (TW_INT8)i_value;
												memcpy((void *)&pONEVALUE->Item, (const void *)&tw_int8, sizeof(TW_INT8));
											}
											break;
											case TWTY_INT16:
											{
												TW_INT16 tw_int16 = (TW_INT16)i_value;
												memcpy((void *)&pONEVALUE->Item, (const void *)&tw_int16, sizeof(TW_INT16));
											}
											break;
											case TWTY_INT32:
											{
												TW_INT32 tw_int32 = (TW_INT32)i_value;
												memcpy((void *)&pONEVALUE->Item, (const void *)&tw_int32, sizeof(TW_INT32));
											}
											break;
											case TWTY_UINT8:
											{
												TW_UINT8 tw_uint8 = (TW_UINT8)i_value;
												memcpy((void *)&pONEVALUE->Item, (const void *)&tw_uint8, sizeof(TW_UINT8));
											}
											break;
											case TWTY_UINT16:
											{
												TW_UINT16 tw_uint16 = (TW_UINT16)i_value;
												memcpy((void *)&pONEVALUE->Item, (const void *)&tw_uint16, sizeof(TW_UINT16));
											}
											break;
											case TWTY_UINT32:
											{
												TW_UINT32 tw_uint32 = (TW_UINT32)i_value;
												memcpy((void *)&pONEVALUE->Item, (const void *)&tw_uint32, sizeof(TW_UINT32));
											}
											break;
											case TWTY_BOOL:
											{
												memcpy((void *)&pONEVALUE->Item, (const void *)&b_value, sizeof(TW_BOOL));
											}
											break;
											case TWTY_STR32:
											case TWTY_STR64:
											case TWTY_STR128:
											case TWTY_STR255:
											{

											}
											break;
											//					case TWTY_STR1024:
											//					case TWTY_UNI512:
											//						break;
											default:
												break;
											}
											break;

										case TWON_RANGE:
											switch (((pTW_RANGE)&tw_capability)->ItemType)
											{
											case TWTY_FIX32:
											{
												TW_INT32 value = (TW_INT32)(f_value * 65536.0 + ((f_value < 0) ? (-0.5) : 0.5));
												TW_FIX32 tw_fix32;
												tw_fix32.Whole = (TW_UINT16)(value >> 16);
												tw_fix32.Frac = (TW_UINT16)(value & 0x0000ffffL);
												memcpy((void *)&((pTW_RANGE)&tw_capability)->CurrentValue, (const void *)&tw_fix32, sizeof(TW_FIX32));
											}
											break;
											case TWTY_FRAME:
											{
												//not implemented!
											}
											break;
											case TWTY_INT8:
											{
												TW_INT8 tw_int8 = (TW_INT8)i_value;
												memcpy((void *)&pRANGE->CurrentValue, (const void *)&tw_int8, sizeof(TW_INT8));
											}
											break;
											case TWTY_INT16:
											{
												TW_INT16 tw_int16 = (TW_INT16)i_value;
												memcpy((void *)&pRANGE->CurrentValue, (const void *)&tw_int16, sizeof(TW_INT16));
											}
											break;
											case TWTY_INT32:
											{
												TW_INT32 tw_int32 = (TW_INT32)i_value;
												memcpy((void *)&pRANGE->CurrentValue, (const void *)&tw_int32, sizeof(TW_INT32));
											}
											break;
											case TWTY_UINT8:
											{
												TW_UINT8 tw_uint8 = (TW_UINT8)i_value;
												memcpy((void *)&pRANGE->CurrentValue, (const void *)&tw_uint8, sizeof(TW_UINT8));
											}
											break;
											case TWTY_UINT16:
											{
												TW_UINT16 tw_uint16 = (TW_UINT16)i_value;
												memcpy((void *)&pRANGE->CurrentValue, (const void *)&tw_uint16, sizeof(TW_UINT16));
											}
											break;
											case TWTY_UINT32:
											{
												TW_UINT32 tw_uint32 = (TW_UINT32)i_value;
												memcpy((void *)&pRANGE->CurrentValue, (const void *)&tw_uint32, sizeof(TW_UINT32));
											}
											break;
											case TWTY_BOOL:
											{
												memcpy((void *)&pRANGE->CurrentValue, (const void *)&b_value, sizeof(TW_BOOL));
											}
											break;
											case TWTY_STR32:
											case TWTY_STR64:
											case TWTY_STR128:
											case TWTY_STR255:
											{

											}
											break;
											//					case TWTY_STR1024:
											//					case TWTY_UNI512:
											//						break;
											default:
												break;
											}
											break;

										}

										if (TWRC_SUCCESS == DSM_Entry(
											&tw_identity,
											&tw_source_identity,
											DG_CONTROL,
											DAT_CAPABILITY,
											MSG_SET,
											(TW_MEMREF)&tw_capability))
										{

										}
										DSM::Unlock(&tw_entrypoint, tw_capability.hContainer);
										DSM::Free(&tw_entrypoint, tw_capability.hContainer);
									}

								}

							}


						}
						++i;
					}
				}
			}
			tw_ret = twain_source_enable(&tw_identity, &tw_source_identity, &tw_userinterface);
			
			if (tw_ret == TWRC_SUCCESS)
			{
				TW_EVENT tw_event;
				memset(&tw_event, 0, sizeof(TW_EVENT));
				
				//timeout to avoid freeze
				time_t now = time(NULL);
				time_t end = now + TWAIN_PROCESS_EVENT_TIMEOUT;
				
				tw_ret = TWRC_NOTDSEVENT;
				while ((tw_ret == TWRC_NOTDSEVENT) && (time(NULL) < end))
				{
					tw_ret = DSM_Entry(
														 &tw_identity,
														 &tw_source_identity,
														 DG_CONTROL,
														 DAT_EVENT,
														 MSG_PROCESSEVENT,
														 (TW_MEMREF)&tw_event);
				}
				if (TWRC_DSEVENT == tw_ret)
				{
					if (MSG_XFERREADY == tw_event.TWMessage)
					{

						
						//scan context
						TW_SETUPMEMXFER tw_setup_mem_xfer;
						TW_IMAGEMEMXFER tw_image_mem_xfer;
						TW_IMAGEMEMXFER image_mem_xfer_template;
						TW_IMAGEINFO tw_imageinfo;
						
						int dpi_x;
						int dpi_y;
						int depth;
						int lines;
						int accumulated_lines;
						int accumulated_bytes;
						int pixels_per_line;
						int bytes_per_line;
						J_COLOR_SPACE jpg_color_space;
						int png_color_type;
						
						bool pending_xfers = true;
						
						while (pending_xfers)
						{
#if VERSIONMAC
							PA_YieldAbsolute();
#endif
							C_BLOB data;
							//reset for each image
							memset(&tw_imageinfo, 0, sizeof(TW_IMAGEINFO));
							
							tw_ret = DSM_Entry(
																 &tw_identity,
																 &tw_source_identity,
																 DG_IMAGE,
																 DAT_IMAGEINFO,
																 MSG_GET,
																 (TW_MEMREF)&tw_imageinfo);
							
							if (tw_ret == TWRC_SUCCESS)
							{
								dpi_x = tw_imageinfo.XResolution.Whole;
								dpi_y = tw_imageinfo.YResolution.Whole;
								depth = tw_imageinfo.BitsPerPixel;
								lines = tw_imageinfo.ImageLength;
								
								accumulated_lines = 0;//in case lines = -1
								accumulated_bytes = 0;//for debug
								pixels_per_line = tw_imageinfo.ImageWidth;
								bytes_per_line = (((tw_imageinfo.ImageWidth * tw_imageinfo.BitsPerPixel) + 7) / 8);
								
								switch (tw_imageinfo.PixelType)
								{
									case TWPT_BW:
									case TWPT_GRAY:
										jpg_color_space = JCS_GRAYSCALE;
										png_color_type = PNG_COLOR_TYPE_GRAY;
										depth = tw_imageinfo.BitsPerPixel;
										break;
									case TWPT_RGB:
										jpg_color_space = JCS_RGB;
										png_color_type = PNG_COLOR_TYPE_RGB;
										depth = tw_imageinfo.BitsPerPixel / 3;
										break;
									default:
										//maybe later...
										//#define TWPT_BW
										//#define TWPT_GRAY
										//#define TWPT_RGB
										//#define TWPT_PALETTE
										//#define TWPT_CMY
										//#define TWPT_CMYK
										//#define TWPT_YUV
										//#define TWPT_YUVK
										//#define TWPT_CIEXYZ
										jpg_color_space = JCS_UNKNOWN;
										png_color_type = PNG_COLOR_TYPE_UNKNOWN;
										break;
								}
								
								bool incremental_image_generation = false;
								//incremental_image_generation not supported
								
								memset(&tw_setup_mem_xfer, 0, sizeof(TW_SETUPMEMXFER));
								
								tw_ret = DSM_Entry(
																	 &tw_identity,
																	 &tw_source_identity,
																	 DG_CONTROL,
																	 DAT_SETUPMEMXFER,
																	 MSG_GET,
																	 (TW_MEMREF)&tw_setup_mem_xfer);
								
								if (tw_ret == TWRC_SUCCESS)
								{
									//setup buffer
									memset(&image_mem_xfer_template, 0, sizeof(TW_IMAGEMEMXFER));
									image_mem_xfer_template.Compression = TWON_DONTCARE16;
									image_mem_xfer_template.BytesPerRow = TWON_DONTCARE32;
									image_mem_xfer_template.Columns = TWON_DONTCARE32;
									image_mem_xfer_template.Rows = TWON_DONTCARE32;
									image_mem_xfer_template.XOffset = TWON_DONTCARE32;
									image_mem_xfer_template.YOffset = TWON_DONTCARE32;
									image_mem_xfer_template.BytesWritten = TWON_DONTCARE32;
									image_mem_xfer_template.Memory.Flags = TWMF_APPOWNS | TWMF_POINTER;
									image_mem_xfer_template.Memory.Length = tw_setup_mem_xfer.Preferred;
									
									TW_HANDLE hMem = (TW_HANDLE)DSM::Alloc(&tw_entrypoint, tw_setup_mem_xfer.Preferred);
									
									if (!hMem) break;//(while)
									
									image_mem_xfer_template.Memory.TheMem = DSM::Lock(&tw_entrypoint, hMem);
									
									bool scan_started = false;
									//this is the real buffer
									memset(&tw_image_mem_xfer, 0, sizeof(TW_IMAGEMEMXFER));
									
									for (;;)
									{
										memcpy(&tw_image_mem_xfer, &image_mem_xfer_template, sizeof(TW_IMAGEMEMXFER));
										memset(tw_image_mem_xfer.Memory.TheMem, 0, tw_image_mem_xfer.Memory.Length);
										
										tw_ret = DSM_Entry(
																			 &tw_identity,
																			 &tw_source_identity,
																			 DG_IMAGE,
																			 DAT_IMAGEMEMXFER,
																			 MSG_GET,
																			 (TW_MEMREF)&tw_image_mem_xfer);
										
										if ((tw_ret == TWRC_SUCCESS) || (tw_ret == TWRC_XFERDONE))
										{
											accumulated_lines += tw_image_mem_xfer.Rows;
											accumulated_bytes = tw_image_mem_xfer.BytesWritten;
											
											if (!scan_started)
											{
												//start of image
												scan_started = true;
											}//!scan_started
											
											if (tw_image_mem_xfer.Memory.Length)
											{
												const uint8_t *p = reinterpret_cast<const uint8_t *>(tw_image_mem_xfer.Memory.TheMem);
												data.addBytes(p, tw_image_mem_xfer.BytesWritten);
											}
											if (tw_ret == TWRC_XFERDONE)
											{
												if (lines == -1)
												{
													lines = accumulated_lines;
												}
												
												pixels_per_line = tw_image_mem_xfer.Columns;
												bytes_per_line = tw_image_mem_xfer.BytesPerRow;
												
												int logical_size = tw_image_mem_xfer.BytesPerRow * lines;
												int actual_size = data.getBytesLength();
												
												if (logical_size > actual_size)
												{
													int padding = logical_size - actual_size;
													std::vector<uint8_t>buf(padding);
													memset(&buf[0], 0xFF, padding);
													data.addBytes(&buf[0], padding);
												}
												if ((jpg_color_space == JCS_GRAYSCALE) || (jpg_color_space = JCS_RGB))
												{
													switch (Param3_format)
													{
														case 0:
														{
															jpg_write_blob(
																						 data, picture,
																						 pixels_per_line,
																						 lines,
																						 depth,
																						 bytes_per_line,
																						 jpg_color_space,
																						 dpi_x,
																						 dpi_y);
														}
															break;
														case 2:
														{
															png_write_blob(
																						 data, picture,
																						 pixels_per_line,
																						 lines,
																						 depth,
																						 bytes_per_line,
																						 png_color_type,
																						 dpi_x,
																						 dpi_y);
														}
															break;
														default:
														{
															size_t outbuffersize = data.getBytesLength();
															unsigned char *outbuffer = (unsigned char *)data.getBytesPtr();
															picture.addBytes((const uint8_t *)&outbuffersize, sizeof(outbuffersize));
															picture.addBytes((const uint8_t *)outbuffer, (unsigned int)outbuffersize);
														}
														break;

													}//switch
													
												}
												break;//for()
												
											}
											else if ((tw_ret == TWRC_CANCEL) || (tw_ret == TWRC_FAILURE))
											{
												break;//for()
											}
										}
										
									}//for
									
									DSM::Unlock(&tw_entrypoint, hMem);
									DSM::Free(&tw_entrypoint, hMem);
									
									if (TWRC_XFERDONE != tw_ret) break;//while()
									
									//update pending_xfers
									TW_PENDINGXFERS tw_pendingxfers;
									memset(&tw_pendingxfers, 0, sizeof(TW_PENDINGXFERS));
									
									tw_ret = DSM_Entry(
																		 &tw_identity,
																		 &tw_source_identity,
																		 DG_CONTROL,
																		 DAT_PENDINGXFERS,
																		 MSG_ENDXFER,
																		 (TW_MEMREF)&tw_pendingxfers);
									
									if (TWRC_SUCCESS == tw_ret)
									{
										if (0 == tw_pendingxfers.Count)
										{
											pending_xfers = false;//no more images
										}//else more images
									}
									else
									{
										pending_xfers = false;//aborted
									}
									
								}
								else
								{
									break;//(while)
								}
							}
							else
							{
								break;//(while)
							}
							
						}//while
						
						if (pending_xfers == true)//broken from while loop
						{
							TW_PENDINGXFERS tw_pendxfers;
							memset(&tw_pendxfers, 0, sizeof(TW_PENDINGXFERS));
							DSM_Entry(
												&tw_identity,
												0,
												DG_CONTROL,
												DAT_PENDINGXFERS,
												MSG_ENDXFER,
												(TW_MEMREF)&tw_pendxfers);
							if (0 != tw_pendxfers.Count)
							{
								memset(&tw_pendxfers, 0, sizeof(TW_PENDINGXFERS));
								DSM_Entry(
													&tw_identity,
													0,
													DG_CONTROL,
													DAT_PENDINGXFERS,
													MSG_RESET,
													(TW_MEMREF)&tw_pendxfers);
							}
						}
					}
				}
				
				tw_ret = twain_source_disable(&tw_identity, &tw_source_identity, &tw_userinterface);
			}
			tw_ret = twain_source_close(&tw_identity, &tw_source_identity);
		}
		
		
		
		tw_ret = twain_dsm_close(&tw_identity, &tw_parent);
	}
	
	if(option)
	{
		json_delete(option);
	}
	
}

#if VERSIONWIN
unsigned __stdcall doScanWin(void *p)
{
	twain_version_info_t *version_info_p = (twain_version_info_t *)p;
	
	C_BLOB data;
	
	int Param3_format = version_info_p->format;
	
	DWORD ParamA_len, ParamB_len, Param1_len, Param2_len;
	HANDLE fmIn = createFmIn2(&ParamA_len, &ParamB_len, &Param1_len, &Param2_len);
	
	if (fmIn)
	{
		DWORD len = (sizeof(DWORD)*4) + ParamA_len + ParamB_len + Param1_len + Param2_len;
		
		LPVOID bufIn = MapViewOfFile(fmIn, FILE_MAP_READ, 0, 0, len);
		
		if (bufIn)
		{
			std::wstring ParamA;
			std::wstring ParamB;
			
			C_TEXT Param1_scanner;
			std::wstring Param2_option;
			
			HANDLE scanEvent_c = createEventforBufIn2(bufIn,
																								ParamA_len, ParamB_len,
																								Param1_len, Param2_len,
																								ParamA, ParamB, Param1_scanner, Param2_option);
			if (scanEvent_c)
			{
				
				/* do stuff and poluate data */
				
				doScan(Param1_scanner,
							 Param2_option, data, /* return value */
							 version_info_p->majorNum,
							 version_info_p->minorNum,
							 version_info_p->language,
							 version_info_p->country,
							 Param3_format);
				
				/* stuff done */
				
				HANDLE fmOut = createFmOut2(&data);
				
				if (fmOut)
				{
					/* tell p that the response is ready */
					HANDLE scanEvent_p = OpenEvent(EVENT_ALL_ACCESS,
																				 FALSE, /* processes created by this process do not inherit this handle */
																				 ParamA.c_str());
					if (scanEvent_p)
					{
						SetEvent(scanEvent_p);
						CloseHandle(scanEvent_p);
					}
					
					/* wait for p to set scanEvent_c */
					WaitForSingleObject(scanEvent_c, INFINITE);
					ResetEvent(scanEvent_c);
					/* now ready to die */
					
					CloseHandle(fmOut);
				}//fmOut
				CloseHandle(scanEvent_c);
			}//scanEvent_c
			UnmapViewOfFile(bufIn);
		}//bufIn
		CloseHandle(fmIn);
	}
	
	_endthreadex(0);
	return 0;
}

#endif

#pragma mark Get Option

void getOption(C_TEXT& Param1_scanner,
							 std::wstring& Param2_option,
							 C_BLOB& data,
							 TW_UINT16 majorNum,
							 TW_UINT16 minorNum,
							 TW_UINT16 language,
							 TW_UINT16 country)
{
	TW_IDENTITY tw_identity;
	TW_USERINTERFACE tw_userinterface;
	HWND tw_parent = NULL;
	
#if USE_TWAIN_DSM
	TW_ENTRYPOINT tw_entrypoint;
#else
	void *tw_entrypoint;
#endif
	
	twain_configure(&tw_identity, &tw_userinterface, &tw_entrypoint, &tw_parent,
									majorNum, minorNum, language, country);
	
	JSONNODE *json_scanner_options = json_new(JSON_NODE);
	JSONNODE *json_scanner_option_values = json_new(JSON_NODE);
	
	TW_UINT16 tw_ret = twain_dsm_open(&tw_identity, &tw_userinterface, &tw_entrypoint, &tw_parent);
	if(tw_ret == TWRC_SUCCESS)
	{
		TW_IDENTITY tw_source_identity;
		tw_ret = twain_source_open(&tw_identity, &tw_source_identity, Param1_scanner);
		
		if(tw_ret == TWRC_SUCCESS)
		{
			TW_CAPABILITY tw_capability;
			memset(&tw_capability, 0, sizeof(TW_CAPABILITY));
			
			tw_capability.Cap = CAP_SUPPORTEDCAPS;
			tw_capability.ConType = 0;
			tw_capability.hContainer = 0;
			
			if(TWRC_SUCCESS == DSM_Entry(
																	 &tw_identity,
																	 &tw_source_identity,
																	 DG_CONTROL,
																	 DAT_CAPABILITY,
																	 MSG_GET,
																	 (TW_MEMREF)&tw_capability))
			{
				if(tw_capability.ConType == TWON_ARRAY)
				{
					std::vector<TW_UINT16>capabilities;
					
					pTW_ARRAY pARRAY = (pTW_ARRAY)DSM::Lock(&tw_entrypoint, tw_capability.hContainer);
					
					for (int i = 0; i < pARRAY->NumItems;++i)
					{
						/* important to downcast */
						TW_UINT16 currentValue = ((pTW_UINT16)(&pARRAY->ItemList))[i];
						if(currentValue != CAP_SUPPORTEDCAPS)
						{
							capabilities.push_back(currentValue);
						}
					}
					
					DSM::Unlock(&tw_entrypoint, tw_capability.hContainer);
					DSM::Free(&tw_entrypoint, tw_capability.hContainer);
					for(std::vector<TW_UINT16>::iterator it = capabilities.begin(); it != capabilities.end(); ++it)
					{
						tw_capability.Cap = *it;
						twain_get_option_value(&tw_identity,
																	 &tw_source_identity,
																	 &tw_capability,
																	 &tw_entrypoint,
																	 json_scanner_options);
						
						twain_get_option_param(&tw_identity,
																	 &tw_source_identity,
																	 &tw_capability,
																	 &tw_entrypoint,
																	 json_scanner_option_values);
#if VERSIONMAC
						PA_YieldAbsolute();
#endif
					}
				}
			}
			tw_ret = twain_source_close(&tw_identity, &tw_source_identity);
		}
		tw_ret = twain_dsm_close(&tw_identity, &tw_parent);
	}
	
	CUTF16String json;
	uint32_t len;
	
	json_stringify(json_scanner_options, json, FALSE);
	json_delete(json_scanner_options);
	len = json.length() * sizeof(PA_Unichar);
	
	data.setBytes((const uint8_t *)&len, sizeof(uint32_t));
	data.addBytes((const uint8_t *)json.c_str(), len);
	
	json_stringify(json_scanner_option_values, json, FALSE);
	json_delete(json_scanner_option_values);
	len = json.length() * sizeof(PA_Unichar);
	
	data.addBytes((const uint8_t *)&len, sizeof(uint32_t));
	data.addBytes((const uint8_t *)json.c_str(), len);
}

#if VERSIONWIN

unsigned __stdcall getOptionWin(void *p)
{
	twain_version_info_t *version_info_p = (twain_version_info_t *)p;
	
	C_BLOB data;
	
	DWORD ParamA_len, ParamB_len, Param1_len, Param2_len;
	HANDLE fmIn = createFmIn2(&ParamA_len, &ParamB_len, &Param1_len, &Param2_len);
	
	if (fmIn)
	{
		DWORD len = (sizeof(DWORD)*4) + ParamA_len + ParamB_len + Param1_len + Param2_len;
		
		LPVOID bufIn = MapViewOfFile(fmIn, FILE_MAP_READ, 0, 0, len);
		
		if (bufIn)
		{
			std::wstring ParamA;
			std::wstring ParamB;
			
			C_TEXT Param1_scanner;
			std::wstring Param2_option;
			
			HANDLE scanEvent_c = createEventforBufIn2(bufIn,
																								ParamA_len, ParamB_len,
																								Param1_len, Param2_len,
																								ParamA, ParamB, Param1_scanner, Param2_option);
			if (scanEvent_c)
			{
				
				/* do stuff and poluate data */
				
				getOption(Param1_scanner,
									Param2_option, /* not used here */
									data, /* return value */
									version_info_p->majorNum,
									version_info_p->minorNum,
									version_info_p->language,
									version_info_p->country);
				
				/* stuff done */
				
				HANDLE fmOut = createFmOut2(&data);
				
				if (fmOut)
				{
					/* tell p that the response is ready */
					HANDLE scanEvent_p = OpenEvent(EVENT_ALL_ACCESS,
																				 FALSE, /* processes created by this process do not inherit this handle */
																				 ParamA.c_str());
					if (scanEvent_p)
					{
						SetEvent(scanEvent_p);
						CloseHandle(scanEvent_p);
					}
					
					/* wait for p to set scanEvent_c */
					WaitForSingleObject(scanEvent_c, INFINITE);
					ResetEvent(scanEvent_c);
					/* now ready to die */
					
					CloseHandle(fmOut);
				}//fmOut
				CloseHandle(scanEvent_c);
			}//scanEvent_c
			UnmapViewOfFile(bufIn);
		}//bufIn
		CloseHandle(fmIn);
	}
	
	_endthreadex(0);
	return 0;
}

#endif
